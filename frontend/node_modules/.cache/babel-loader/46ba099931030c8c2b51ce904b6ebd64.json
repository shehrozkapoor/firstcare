{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n\n  privateMap.set(obj, value);\n}\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate'); // This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\n\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\n\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\n\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\n\nvar _engineListeners = /*#__PURE__*/new WeakMap();\n\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n\n  var _super = _createSuper(Formulas);\n\n  function Formulas() {\n    var _this;\n\n    _classCallCheck(this, Formulas);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n\n    return _this;\n  }\n\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n          _this8 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      }); // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.undo();\n      }); // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            eventName = _ref2[0],\n            listener = _ref2[1];\n\n        return _this8.engine.on(eventName, listener);\n      });\n\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            eventName = _ref4[0],\n            listener = _ref4[1];\n\n        return _this9.engine.off(eventName, listener);\n      });\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            eventName = _ref6[0],\n            listener = _ref6[1];\n\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n\n      _classPrivateFieldSet(this, _engineListeners, null);\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address; // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n            row = _ref7.row,\n            col = _ref7.col,\n            sheet = _ref7.sheet;\n\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n            row = _ref8.row,\n            col = _ref8.col;\n\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId); // It will just re-render certain cell when necessary.\n\n          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n\n      return value;\n    }\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopLeftCorner()),\n        end: withSheetId(sourceRange.getBottomRightCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopLeftCorner()),\n        end: withSheetId(targetRange.getBottomRightCorner())\n      }; // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n\n          return;\n        }\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n              row = _ref10[0],\n              prop = _ref10[1],\n              newValue = _ref10[3];\n\n          var column = _this14.hot.propToCol(prop);\n\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                  row = _ref12[0],\n                  column = _ref12[1],\n                  newValue = _ref12[2];\n\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n            row = _ref14[0],\n            prop = _ref14[1],\n            newValue = _ref14[3];\n\n        var column = _this15.hot.propToCol(prop);\n\n        if (!isNumeric(column)) {\n          return;\n        }\n\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n          _this20 = this;\n\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n\n  return Formulas;\n}(BasePlugin);","map":{"version":3,"sources":["/Users/shehrozkapoor/Desktop/FIRST_CARE/firstcare-frontend/node_modules/handsontable/plugins/formulas/formulas.mjs"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_typeof","obj","constructor","prototype","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","toString","call","slice","name","test","len","arr2","_i","_arr","_n","_d","_s","_e","next","done","value","err","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","_get","Reflect","get","property","receiver","base","_superPropBase","desc","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classPrivateFieldInitSpec","privateMap","_checkPrivateRedeclaration","set","privateCollection","has","_classPrivateFieldSet","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","BasePlugin","staticRegister","error","warn","isNumeric","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","getEngineSettingsWithOverrides","isArrayOfArrays","toUpperCaseFirst","Hooks","PLUGIN_KEY","PLUGIN_PRIORITY","ROW_MOVE_UNDO_REDO_NAME","getSingleton","register","isBlockedSource","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","Formulas","_BasePlugin","_super","_this","_len","_args","_key","concat","_this2","onEngineValuesUpdated","_this3","onEngineNamedExpressionsAdded","_this4","onEngineNamedExpressionsRemoved","_this5","onEngineSheetAdded","_this6","onEngineSheetRenamed","_this7","onEngineSheetRemoved","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this8","enabled","doesSheetExist","newSheetName","addSheet","getSourceDataArray","addHook","onBeforeLoadData","onAfterLoadData","onModifyData","onModifySourceData","onBeforeValidate","onAfterSetSourceDataAtCell","onAfterSetDataAtCell","onBeforeCreateRow","onBeforeCreateCol","onAfterCreateRow","onAfterCreateCol","onBeforeRemoveRow","onBeforeRemoveCol","onAfterRemoveRow","onAfterRemoveCol","actionType","undo","redo","onAfterDetachChild","onBeforeAutofill","_ref","_ref2","eventName","listener","on","disablePlugin","_this9","_ref3","_ref4","off","updatePlugin","newSettings","updateConfig","pluginSettings","switchSheet","data","destroy","_this10","_ref5","_this10$engine","_ref6","getPhysicalIndexPosition","visualIndex","physicalIndex","entriesCount","sourceEntriesCount","contained","toPhysicalRowPosition","row","undefined","toPhysicalRow","countRows","countSourceRows","toPhysicalColumnPosition","column","toPhysicalColumn","countCols","countSourceCols","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","sheetId","loadData","getCellType","sheet","physicalRow","physicalColumn","col","isFormulaCellType","doesCellHaveFormula","renderDependentSheets","dependentCells","_this11","renderSelf","affectedSheetIds","Set","change","_change$address","address","add","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","_this12","changedCells","stringifyAddress","_change$address2","_ref7","changedCellsSet","map","_change$address3","_change$address4","_ref8","visualRow","toVisualRow","visualColumn","toVisualColumn","addressId","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","setCellContents","prop","propToCol","cellValue","getCellValue","fillData","sourceRange","targetRange","_this13","withSheetId","range","engineSourceRange","start","getTopLeftCorner","end","getBottomRightCorner","engineTargetRange","getFillRangeData","sourceData","initialLoad","includes","sourceDataArray","isItPossibleToReplaceSheetContent","valueHolder","ioMode","cellType","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","_this14","outOfBoundsChanges","batch","_ref9","_ref10","addHookOnce","outOfBoundsDependentCells","_ref11","_ref12","_this15","_ref13","_ref14","amount","isItPossibleToAddRows","isItPossibleToAddColumns","physicalRows","_this16","possible","every","isItPossibleToRemoveRows","physicalColumns","_this17","isItPossibleToRemoveColumns","addRows","addColumns","_this18","descendingPhysicalRows","sort","reverse","removeRows","_this19","descendingPhysicalColumns","removeColumns","parent","element","finalElementRowIndex","_element$__children","_this20","rowsData","__children","relativeRowIndex","colIndex","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate'); // This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\n\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\n\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\n\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\n\nvar _engineListeners = /*#__PURE__*/new WeakMap();\n\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n\n  var _super = _createSuper(Formulas);\n\n  function Formulas() {\n    var _this;\n\n    _classCallCheck(this, Formulas);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n\n    return _this;\n  }\n\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n          _this8 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      }); // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.undo();\n      }); // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            eventName = _ref2[0],\n            listener = _ref2[1];\n\n        return _this8.engine.on(eventName, listener);\n      });\n\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            eventName = _ref4[0],\n            listener = _ref4[1];\n\n        return _this9.engine.off(eventName, listener);\n      });\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            eventName = _ref6[0],\n            listener = _ref6[1];\n\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n\n      _classPrivateFieldSet(this, _engineListeners, null);\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n            row = _ref7.row,\n            col = _ref7.col,\n            sheet = _ref7.sheet;\n\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n            row = _ref8.row,\n            col = _ref8.col;\n\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId); // It will just re-render certain cell when necessary.\n\n          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n\n      return value;\n    }\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopLeftCorner()),\n        end: withSheetId(sourceRange.getBottomRightCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopLeftCorner()),\n        end: withSheetId(targetRange.getBottomRightCorner())\n      }; // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n\n          return;\n        }\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n              row = _ref10[0],\n              prop = _ref10[1],\n              newValue = _ref10[3];\n\n          var column = _this14.hot.propToCol(prop);\n\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                  row = _ref12[0],\n                  column = _ref12[1],\n                  newValue = _ref12[2];\n\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n            row = _ref14[0],\n            prop = _ref14[1],\n            newValue = _ref14[3];\n\n        var column = _this15.hot.propToCol(prop);\n\n        if (!isNumeric(column)) {\n          return;\n        }\n\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n          _this20 = this;\n\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n\n  return Formulas;\n}(BasePlugin);"]},"metadata":{},"sourceType":"module"}