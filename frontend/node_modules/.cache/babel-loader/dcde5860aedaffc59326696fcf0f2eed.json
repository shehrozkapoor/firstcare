{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nimport GlobalMeta from \"./metaLayers/globalMeta.mjs\";\nimport TableMeta from \"./metaLayers/tableMeta.mjs\";\nimport ColumnMeta from \"./metaLayers/columnMeta.mjs\";\nimport CellMeta from \"./metaLayers/cellMeta.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\n/**\n * With the Meta Manager class, it can be possible to manage with meta objects for different layers in\n * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to\n * be passed as physical values.\n *\n * The diagram of the meta layers:\n * +-------------+.\n * │ GlobalMeta  │\n * │ (prototype) │\n * +-------------+\\\n *       │         \\\n *       │          \\\n *      \\│/         _\\|\n * +-------------+    +-------------+.\n * │ TableMeta   │    │ ColumnMeta  │\n * │ (instance)  │    │ (prototype) │\n * +-------------+    +-------------+.\n *                         │\n *                         │\n *                        \\│/\n *                    +-------------+.\n *                    │  CellMeta   │\n *                    │ (instance)  │\n *                    +-------------+.\n *\n * A more detailed description of the specific layers can be found in the \"metaLayers/\" modules description.\n */\n\nvar MetaManager = /*#__PURE__*/function () {\n  function MetaManager(hot) {\n    var _this = this;\n\n    var customSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var metaMods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, MetaManager);\n    /**\n     * @type {Handsontable}\n     */\n\n\n    this.hot = hot;\n    /**\n     * @type {GlobalMeta}\n     */\n\n    this.globalMeta = new GlobalMeta(hot);\n    this.globalMeta.updateMeta(customSettings);\n    /**\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = new TableMeta(this.globalMeta);\n    /**\n     * @type {ColumnMeta}\n     */\n\n    this.columnMeta = new ColumnMeta(this.globalMeta);\n    /**\n     * @type {CellMeta}\n     */\n\n    this.cellMeta = new CellMeta(this.columnMeta);\n    metaMods.forEach(function (ModifierClass) {\n      return new ModifierClass(_this);\n    });\n  }\n  /**\n   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.\n   * Other layers inherites all properties from this. Adding, removing, or changing property in that\n   * object has a direct reflection to all layers.\n   *\n   * @returns {object}\n   */\n\n\n  _createClass(MetaManager, [{\n    key: \"getGlobalMeta\",\n    value: function getGlobalMeta() {\n      return this.globalMeta.getMeta();\n    }\n    /**\n     * Updates global settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateGlobalMeta\",\n    value: function updateGlobalMeta(settings) {\n      this.globalMeta.updateMeta(settings);\n    }\n    /**\n     * Gets settings object that was passed in the Handsontable constructor. That layer contains all\n     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.\n     * Adding, removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getTableMeta\",\n    value: function getTableMeta() {\n      return this.tableMeta.getMeta();\n    }\n    /**\n     * Updates table settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateTableMeta\",\n    value: function updateTableMeta(settings) {\n      this.tableMeta.updateMeta(settings);\n    }\n    /**\n     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable\n     * settings. Each column in the Handsontable is associated with a unique meta object which identified by\n     * the physical column index. Adding, removing, or changing property in that object has a direct reflection\n     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower\n     * layers (prototype lookup).\n     *\n     * @param {number} physicalColumn The physical column index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getColumnMeta\",\n    value: function getColumnMeta(physicalColumn) {\n      return this.columnMeta.getMeta(physicalColumn);\n    }\n    /**\n     * Updates column meta object by merging settings with the current state.\n     *\n     * @param {number} physicalColumn The physical column index which points what column meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateColumnMeta\",\n    value: function updateColumnMeta(physicalColumn, settings) {\n      this.columnMeta.updateMeta(physicalColumn, settings);\n    }\n    /**\n     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by\n     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't\n     * exist in that layer, it is looked up through a prototype to the highest layer. Starting\n     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,\n     * removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {object} options Additional options that are used to extend the cell meta object.\n     * @param {number} options.visualRow The visual row index of the currently requested cell meta object.\n     * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getCellMeta\",\n    value: function getCellMeta(physicalRow, physicalColumn, _ref) {\n      var visualRow = _ref.visualRow,\n          visualColumn = _ref.visualColumn;\n      var cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);\n      cellMeta.visualRow = visualRow;\n      cellMeta.visualCol = visualColumn;\n      cellMeta.row = physicalRow;\n      cellMeta.col = physicalColumn;\n      this.runLocalHooks('afterGetCellMeta', cellMeta);\n      return cellMeta;\n    }\n    /**\n     * Gets a value (defined by the `key` property) from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key Defines the value that will be returned from the cell meta object.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getCellMetaKeyValue\",\n    value: function getCellMetaKeyValue(physicalRow, physicalColumn, key) {\n      if (typeof key !== 'string') {\n        throw new Error('The passed cell meta object key is not a string');\n      }\n\n      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Sets settings object for cell meta object defined by \"key\" property.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to set.\n     * @param {*} value Value to save.\n     */\n\n  }, {\n    key: \"setCellMeta\",\n    value: function setCellMeta(physicalRow, physicalColumn, key, value) {\n      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n    }\n    /**\n     * Updates cell meta object by merging settings with the current state.\n     *\n     * @param {number} physicalRow The physical row index which points what cell meta object is updated.\n     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateCellMeta\",\n    value: function updateCellMeta(physicalRow, physicalColumn, settings) {\n      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n    }\n    /**\n     * Removes a property defined by the \"key\" argument from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to remove.\n     */\n\n  }, {\n    key: \"removeCellMeta\",\n    value: function removeCellMeta(physicalRow, physicalColumn, key) {\n      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta\n     * objects are created lazy, the length of the returned collection depends on how and when the\n     * table has asked for access to that meta objects.\n     *\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMeta\",\n    value: function getCellsMeta() {\n      return this.cellMeta.getMetas();\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation but for\n     * specyfic row index.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMetaAtRow\",\n    value: function getCellsMetaAtRow(physicalRow) {\n      return this.cellMeta.getMetasAtRow(physicalRow);\n    }\n    /**\n     * Creates one or more rows at specific position.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is added.\n     * @param {number} [amount=1] An amount of rows to add.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createRow(physicalRow, amount);\n    }\n    /**\n     * Removes one or more rows from the collection.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is removed.\n     * @param {number} [amount=1] An amount rows to remove.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeRow(physicalRow, amount);\n    }\n    /**\n     * Creates one or more columns at specific position.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is added.\n     * @param {number} [amount=1] An amount of columns to add.\n     */\n\n  }, {\n    key: \"createColumn\",\n    value: function createColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createColumn(physicalColumn, amount);\n      this.columnMeta.createColumn(physicalColumn, amount);\n    }\n    /**\n     * Removes one or more columns from the collection.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is removed.\n     * @param {number} [amount=1] An amount of columns to remove.\n     */\n\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeColumn(physicalColumn, amount);\n      this.columnMeta.removeColumn(physicalColumn, amount);\n    }\n    /**\n     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.\n     */\n\n  }, {\n    key: \"clearCellsCache\",\n    value: function clearCellsCache() {\n      this.cellMeta.clearCache();\n    }\n    /**\n     * Clears all saved cell and columns meta objects.\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cellMeta.clearCache();\n      this.columnMeta.clearCache();\n    }\n  }]);\n\n  return MetaManager;\n}();\n\nexport { MetaManager as default };\nmixin(MetaManager, localHooks);","map":{"version":3,"sources":["/Users/shehrozkapoor/Desktop/FIRST_CARE/firstcare-frontend/node_modules/handsontable/dataMap/metaManager/index.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","GlobalMeta","TableMeta","ColumnMeta","CellMeta","localHooks","mixin","MetaManager","hot","_this","customSettings","arguments","undefined","metaMods","globalMeta","updateMeta","tableMeta","columnMeta","cellMeta","forEach","ModifierClass","value","getGlobalMeta","getMeta","updateGlobalMeta","settings","getTableMeta","updateTableMeta","getColumnMeta","physicalColumn","updateColumnMeta","getCellMeta","physicalRow","_ref","visualRow","visualColumn","visualCol","row","col","runLocalHooks","getCellMetaKeyValue","Error","setCellMeta","setMeta","updateCellMeta","removeCellMeta","removeMeta","getCellsMeta","getMetas","getCellsMetaAtRow","getMetasAtRow","createRow","amount","removeRow","createColumn","removeColumn","clearCellsCache","clearCache","default"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport GlobalMeta from \"./metaLayers/globalMeta.mjs\";\nimport TableMeta from \"./metaLayers/tableMeta.mjs\";\nimport ColumnMeta from \"./metaLayers/columnMeta.mjs\";\nimport CellMeta from \"./metaLayers/cellMeta.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\n/**\n * With the Meta Manager class, it can be possible to manage with meta objects for different layers in\n * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to\n * be passed as physical values.\n *\n * The diagram of the meta layers:\n * +-------------+.\n * │ GlobalMeta  │\n * │ (prototype) │\n * +-------------+\\\n *       │         \\\n *       │          \\\n *      \\│/         _\\|\n * +-------------+    +-------------+.\n * │ TableMeta   │    │ ColumnMeta  │\n * │ (instance)  │    │ (prototype) │\n * +-------------+    +-------------+.\n *                         │\n *                         │\n *                        \\│/\n *                    +-------------+.\n *                    │  CellMeta   │\n *                    │ (instance)  │\n *                    +-------------+.\n *\n * A more detailed description of the specific layers can be found in the \"metaLayers/\" modules description.\n */\n\nvar MetaManager = /*#__PURE__*/function () {\n  function MetaManager(hot) {\n    var _this = this;\n\n    var customSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var metaMods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, MetaManager);\n\n    /**\n     * @type {Handsontable}\n     */\n    this.hot = hot;\n    /**\n     * @type {GlobalMeta}\n     */\n\n    this.globalMeta = new GlobalMeta(hot);\n    this.globalMeta.updateMeta(customSettings);\n    /**\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = new TableMeta(this.globalMeta);\n    /**\n     * @type {ColumnMeta}\n     */\n\n    this.columnMeta = new ColumnMeta(this.globalMeta);\n    /**\n     * @type {CellMeta}\n     */\n\n    this.cellMeta = new CellMeta(this.columnMeta);\n    metaMods.forEach(function (ModifierClass) {\n      return new ModifierClass(_this);\n    });\n  }\n  /**\n   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.\n   * Other layers inherites all properties from this. Adding, removing, or changing property in that\n   * object has a direct reflection to all layers.\n   *\n   * @returns {object}\n   */\n\n\n  _createClass(MetaManager, [{\n    key: \"getGlobalMeta\",\n    value: function getGlobalMeta() {\n      return this.globalMeta.getMeta();\n    }\n    /**\n     * Updates global settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateGlobalMeta\",\n    value: function updateGlobalMeta(settings) {\n      this.globalMeta.updateMeta(settings);\n    }\n    /**\n     * Gets settings object that was passed in the Handsontable constructor. That layer contains all\n     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.\n     * Adding, removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getTableMeta\",\n    value: function getTableMeta() {\n      return this.tableMeta.getMeta();\n    }\n    /**\n     * Updates table settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateTableMeta\",\n    value: function updateTableMeta(settings) {\n      this.tableMeta.updateMeta(settings);\n    }\n    /**\n     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable\n     * settings. Each column in the Handsontable is associated with a unique meta object which identified by\n     * the physical column index. Adding, removing, or changing property in that object has a direct reflection\n     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower\n     * layers (prototype lookup).\n     *\n     * @param {number} physicalColumn The physical column index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getColumnMeta\",\n    value: function getColumnMeta(physicalColumn) {\n      return this.columnMeta.getMeta(physicalColumn);\n    }\n    /**\n     * Updates column meta object by merging settings with the current state.\n     *\n     * @param {number} physicalColumn The physical column index which points what column meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateColumnMeta\",\n    value: function updateColumnMeta(physicalColumn, settings) {\n      this.columnMeta.updateMeta(physicalColumn, settings);\n    }\n    /**\n     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by\n     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't\n     * exist in that layer, it is looked up through a prototype to the highest layer. Starting\n     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,\n     * removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {object} options Additional options that are used to extend the cell meta object.\n     * @param {number} options.visualRow The visual row index of the currently requested cell meta object.\n     * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getCellMeta\",\n    value: function getCellMeta(physicalRow, physicalColumn, _ref) {\n      var visualRow = _ref.visualRow,\n          visualColumn = _ref.visualColumn;\n      var cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);\n      cellMeta.visualRow = visualRow;\n      cellMeta.visualCol = visualColumn;\n      cellMeta.row = physicalRow;\n      cellMeta.col = physicalColumn;\n      this.runLocalHooks('afterGetCellMeta', cellMeta);\n      return cellMeta;\n    }\n    /**\n     * Gets a value (defined by the `key` property) from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key Defines the value that will be returned from the cell meta object.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getCellMetaKeyValue\",\n    value: function getCellMetaKeyValue(physicalRow, physicalColumn, key) {\n      if (typeof key !== 'string') {\n        throw new Error('The passed cell meta object key is not a string');\n      }\n\n      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Sets settings object for cell meta object defined by \"key\" property.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to set.\n     * @param {*} value Value to save.\n     */\n\n  }, {\n    key: \"setCellMeta\",\n    value: function setCellMeta(physicalRow, physicalColumn, key, value) {\n      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n    }\n    /**\n     * Updates cell meta object by merging settings with the current state.\n     *\n     * @param {number} physicalRow The physical row index which points what cell meta object is updated.\n     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateCellMeta\",\n    value: function updateCellMeta(physicalRow, physicalColumn, settings) {\n      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n    }\n    /**\n     * Removes a property defined by the \"key\" argument from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to remove.\n     */\n\n  }, {\n    key: \"removeCellMeta\",\n    value: function removeCellMeta(physicalRow, physicalColumn, key) {\n      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta\n     * objects are created lazy, the length of the returned collection depends on how and when the\n     * table has asked for access to that meta objects.\n     *\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMeta\",\n    value: function getCellsMeta() {\n      return this.cellMeta.getMetas();\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation but for\n     * specyfic row index.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMetaAtRow\",\n    value: function getCellsMetaAtRow(physicalRow) {\n      return this.cellMeta.getMetasAtRow(physicalRow);\n    }\n    /**\n     * Creates one or more rows at specific position.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is added.\n     * @param {number} [amount=1] An amount of rows to add.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createRow(physicalRow, amount);\n    }\n    /**\n     * Removes one or more rows from the collection.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is removed.\n     * @param {number} [amount=1] An amount rows to remove.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeRow(physicalRow, amount);\n    }\n    /**\n     * Creates one or more columns at specific position.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is added.\n     * @param {number} [amount=1] An amount of columns to add.\n     */\n\n  }, {\n    key: \"createColumn\",\n    value: function createColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createColumn(physicalColumn, amount);\n      this.columnMeta.createColumn(physicalColumn, amount);\n    }\n    /**\n     * Removes one or more columns from the collection.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is removed.\n     * @param {number} [amount=1] An amount of columns to remove.\n     */\n\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeColumn(physicalColumn, amount);\n      this.columnMeta.removeColumn(physicalColumn, amount);\n    }\n    /**\n     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.\n     */\n\n  }, {\n    key: \"clearCellsCache\",\n    value: function clearCellsCache() {\n      this.cellMeta.clearCache();\n    }\n    /**\n     * Clears all saved cell and columns meta objects.\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cellMeta.clearCache();\n      this.columnMeta.clearCache();\n    }\n  }]);\n\n  return MetaManager;\n}();\n\nexport { MetaManager as default };\nmixin(MetaManager, localHooks);"]},"metadata":{},"sourceType":"module"}