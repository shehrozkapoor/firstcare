{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nvar _templateObject;\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { isPressedCtrlKey } from \"./../utils/keyStateObserver.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * @class Selection\n * @util\n */\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n\n\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative; // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n      var coordsClone = coords.clone();\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coordsClone);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coordsClone);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      } // We are creating copy. We would like to modify just the end of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n\n      var coordsClone = coords.clone();\n      this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coordsClone.row, coordsClone.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit() // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .adjustCoordinates(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n          if (isRowSelected) {\n            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {number} layerLevel The layer level.\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     *\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\n     * otherwise.\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\n     * otherwise.\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // We can't select cells when there is no data.\n\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n\n      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));\n      this.finish();\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n     * `endColumn`.\n     *\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\n     *\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(headerLevel, start));\n        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {number} startRow Visual row index from which the selection starts.\n     * @param {number} [endRow] Visual row index from to the selection finishes.\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\n     *                                  The value can take -1 to -N, where -1 means the header\n     *                                  closest to the cells.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));\n        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n\n      if (!this.isSelected()) {\n        return;\n      }\n\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().adjustCoordinates(this.selectedRange.current()); // Rewriting rendered ranges going through all layers.\n\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      } // Reverting starting layer for the Highlight.\n\n\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"sources":["/Users/shehrozkapoor/Desktop/FIRST_CARE/firstcare-frontend/node_modules/handsontable/selection/selection.mjs"],"names":["_templateObject","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Highlight","AREA_TYPE","HEADER_TYPE","CELL_TYPE","SelectionRange","CellCoords","isPressedCtrlKey","createObjectPropListener","mixin","isUndefined","arrayEach","localHooks","Transformation","detectSelectionType","isValidCoord","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","Selection","settings","tableProps","_this","inProgress","selectedByCorner","selectedByRowHeader","Set","selectedByColumnHeader","selectedRange","highlight","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","disabledCellSelection","row","column","isDisabledCellSelection","cellCornerVisible","isCellCornerVisible","apply","arguments","areaCornerVisible","isAreaCornerVisible","visualToRenderableCoords","coords","renderableToVisualCoords","transformation","countRows","countRowsTranslated","countCols","countColsTranslated","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","args","_key","runLocalHooks","concat","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","getSelectedRange","begin","finish","isInProgress","setRangeStart","multipleSelection","fragment","undefined","isMultipleMode","selectionMode","isMultipleSelection","isRowNegative","isColumnNegative","col","coordsClone","clone","clear","add","getLayerLevel","setRangeEnd","setRangeStartOnly","isEmpty","cellRange","current","setTo","getCell","isEnabledFor","commit","adjustCoordinates","layerLevel","getAreas","getHeaders","getActiveHeaders","useLayerLevel","areaHighlight","createOrGetArea","headerHighlight","createOrGetHeader","activeHeaderHighlight","createOrGetActiveHeader","isMultiple","to","previousRange","previous","areAnyRowsRendered","areAnyColumnsRendered","headerCellRange","isSelectedByAnyHeader","normalize","isEntireRowSelected","isRowSelected","getWidth","isEntireColumnSelected","isColumnSelected","getHeight","isMultipleListener","isSingle","transformStart","rowDelta","colDelta","force","transformEnd","size","isSelected","isSelectedByRowHeader","isSelectedByCorner","has","isSelectedByColumnHeader","inInSelection","includes","fillHandle","isEditorOpened","Number","isInteger","deselect","selectAll","includeRowHeaders","includeColumnHeaders","nrOfRows","nrOfColumns","startCoords","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","isValid","some","selection","_selectionSchemaNorma","_selectionSchemaNorma2","rowStart","columnStart","rowEnd","columnEnd","_isValid","_selectionSchemaNorma3","_selectionSchemaNorma4","selectColumns","startColumn","endColumn","headerLevel","start","end","selectRows","startRow","endRow","refresh","customSelections","getCustomSelections","forEach","customSelection","cellHighlight","currentLayer"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nvar _templateObject;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { isPressedCtrlKey } from \"./../utils/keyStateObserver.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * @class Selection\n * @util\n */\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative; // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n      var coordsClone = coords.clone();\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coordsClone);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coordsClone);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      } // We are creating copy. We would like to modify just the end of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n\n      var coordsClone = coords.clone();\n      this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coordsClone.row, coordsClone.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit() // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .adjustCoordinates(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n          if (isRowSelected) {\n            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {number} layerLevel The layer level.\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     *\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\n     * otherwise.\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\n     * otherwise.\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // We can't select cells when there is no data.\n\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n\n      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));\n      this.finish();\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n     * `endColumn`.\n     *\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\n     *\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(headerLevel, start));\n        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {number} startRow Visual row index from which the selection starts.\n     * @param {number} [endRow] Visual row index from to the selection finishes.\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\n     *                                  The value can take -1 to -N, where -1 means the header\n     *                                  closest to the cells.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));\n        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n\n      if (!this.isSelected()) {\n        return;\n      }\n\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().adjustCoordinates(this.selectedRange.current()); // Rewriting rendered ranges going through all layers.\n\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      } // Reverting starting layer for the Highlight.\n\n\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;"]},"metadata":{},"sourceType":"module"}