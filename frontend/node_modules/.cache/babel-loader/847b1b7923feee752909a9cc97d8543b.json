{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nimport Hooks from \"../../../pluginHooks.mjs\";\nimport { hasOwnProperty } from \"../../../helpers/object.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\n/**\n * @class DynamicCellMetaMod\n *\n * The `DynamicCellMetaMod` modifier allows for extending cell meta objects\n * (returned by `getCellMeta()` from `MetaManager`)\n * by user-specific properties.\n *\n * The user-specific properties can be added and changed dynamically,\n * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n * or by Handsontable's `cells` option.\n *\n * The `getCellMeta()` method is used widely throughout the source code.\n * To boost the method's execution time,\n * the logic is triggered only once per one Handsontable slow render cycle.\n */\n\nexport var DynamicCellMetaMod = /*#__PURE__*/function () {\n  function DynamicCellMetaMod(metaManager) {\n    var _this = this;\n\n    _classCallCheck(this, DynamicCellMetaMod);\n    /**\n     * @type {MetaManager}\n     */\n\n\n    this.metaManager = metaManager;\n    /**\n     * @type {Map}\n     */\n\n    this.metaSyncMemo = new Map();\n    metaManager.addLocalHook('afterGetCellMeta', function (cellMeta) {\n      return _this.extendCellMeta(cellMeta);\n    });\n    Hooks.getSingleton().add('beforeRender', function (forceFullRender) {\n      if (forceFullRender) {\n        _this.metaSyncMemo.clear();\n      }\n    }, this.metaManager.hot);\n  }\n  /**\n   * Extends the cell meta object by user-specific properties.\n   *\n   * The cell meta object can be extended dynamically,\n   * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n   * or by Handsontable's `cells` option.\n   *\n   * To boost performance, the extending process is triggered only once per one slow Handsontable render cycle.\n   *\n   * @param {object} cellMeta The cell meta object.\n   */\n\n\n  _createClass(DynamicCellMetaMod, [{\n    key: \"extendCellMeta\",\n    value: function extendCellMeta(cellMeta) {\n      var _this$metaSyncMemo$ge;\n\n      var physicalRow = cellMeta.row,\n          physicalColumn = cellMeta.col;\n\n      if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {\n        return;\n      }\n\n      var visualRow = cellMeta.visualRow,\n          visualCol = cellMeta.visualCol;\n      var hot = this.metaManager.hot;\n      var prop = hot.colToProp(visualCol);\n      cellMeta.prop = prop;\n      hot.runHooks('beforeGetCellMeta', visualRow, visualCol, cellMeta); // extend a `type` value, added or changed in the `beforeGetCellMeta` hook\n\n      var cellType = hasOwnProperty(cellMeta, 'type') ? cellMeta.type : null;\n      var cellSettings = isFunction(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;\n\n      if (cellType) {\n        if (cellSettings) {\n          var _cellSettings$type;\n\n          cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;\n        } else {\n          cellSettings = {\n            type: cellType\n          };\n        }\n      }\n\n      if (cellSettings) {\n        this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);\n      }\n\n      hot.runHooks('afterGetCellMeta', visualRow, visualCol, cellMeta);\n\n      if (!this.metaSyncMemo.has(physicalRow)) {\n        this.metaSyncMemo.set(physicalRow, new Set());\n      }\n\n      this.metaSyncMemo.get(physicalRow).add(physicalColumn);\n    }\n  }]);\n\n  return DynamicCellMetaMod;\n}();","map":{"version":3,"sources":["/Users/shehrozkapoor/Desktop/FIRST_CARE/firstcare-frontend/node_modules/handsontable/dataMap/metaManager/mods/dynamicCellMeta.mjs"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Hooks","hasOwnProperty","isFunction","DynamicCellMetaMod","metaManager","_this","metaSyncMemo","Map","addLocalHook","cellMeta","extendCellMeta","getSingleton","add","forceFullRender","clear","hot","value","_this$metaSyncMemo$ge","physicalRow","row","physicalColumn","col","get","has","visualRow","visualCol","prop","colToProp","runHooks","cellType","type","cellSettings","cells","_cellSettings$type","updateCellMeta","set","Set"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.set.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport Hooks from \"../../../pluginHooks.mjs\";\nimport { hasOwnProperty } from \"../../../helpers/object.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\n/**\n * @class DynamicCellMetaMod\n *\n * The `DynamicCellMetaMod` modifier allows for extending cell meta objects\n * (returned by `getCellMeta()` from `MetaManager`)\n * by user-specific properties.\n *\n * The user-specific properties can be added and changed dynamically,\n * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n * or by Handsontable's `cells` option.\n *\n * The `getCellMeta()` method is used widely throughout the source code.\n * To boost the method's execution time,\n * the logic is triggered only once per one Handsontable slow render cycle.\n */\n\nexport var DynamicCellMetaMod = /*#__PURE__*/function () {\n  function DynamicCellMetaMod(metaManager) {\n    var _this = this;\n\n    _classCallCheck(this, DynamicCellMetaMod);\n\n    /**\n     * @type {MetaManager}\n     */\n    this.metaManager = metaManager;\n    /**\n     * @type {Map}\n     */\n\n    this.metaSyncMemo = new Map();\n    metaManager.addLocalHook('afterGetCellMeta', function (cellMeta) {\n      return _this.extendCellMeta(cellMeta);\n    });\n    Hooks.getSingleton().add('beforeRender', function (forceFullRender) {\n      if (forceFullRender) {\n        _this.metaSyncMemo.clear();\n      }\n    }, this.metaManager.hot);\n  }\n  /**\n   * Extends the cell meta object by user-specific properties.\n   *\n   * The cell meta object can be extended dynamically,\n   * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),\n   * or by Handsontable's `cells` option.\n   *\n   * To boost performance, the extending process is triggered only once per one slow Handsontable render cycle.\n   *\n   * @param {object} cellMeta The cell meta object.\n   */\n\n\n  _createClass(DynamicCellMetaMod, [{\n    key: \"extendCellMeta\",\n    value: function extendCellMeta(cellMeta) {\n      var _this$metaSyncMemo$ge;\n\n      var physicalRow = cellMeta.row,\n          physicalColumn = cellMeta.col;\n\n      if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {\n        return;\n      }\n\n      var visualRow = cellMeta.visualRow,\n          visualCol = cellMeta.visualCol;\n      var hot = this.metaManager.hot;\n      var prop = hot.colToProp(visualCol);\n      cellMeta.prop = prop;\n      hot.runHooks('beforeGetCellMeta', visualRow, visualCol, cellMeta); // extend a `type` value, added or changed in the `beforeGetCellMeta` hook\n\n      var cellType = hasOwnProperty(cellMeta, 'type') ? cellMeta.type : null;\n      var cellSettings = isFunction(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;\n\n      if (cellType) {\n        if (cellSettings) {\n          var _cellSettings$type;\n\n          cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;\n        } else {\n          cellSettings = {\n            type: cellType\n          };\n        }\n      }\n\n      if (cellSettings) {\n        this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);\n      }\n\n      hot.runHooks('afterGetCellMeta', visualRow, visualCol, cellMeta);\n\n      if (!this.metaSyncMemo.has(physicalRow)) {\n        this.metaSyncMemo.set(physicalRow, new Set());\n      }\n\n      this.metaSyncMemo.get(physicalRow).add(physicalColumn);\n    }\n  }]);\n\n  return DynamicCellMetaMod;\n}();"]},"metadata":{},"sourceType":"module"}