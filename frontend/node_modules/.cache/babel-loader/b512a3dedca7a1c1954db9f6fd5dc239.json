{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nimport { toUpperCaseFirst } from \"../helpers/string.mjs\";\nimport { isFunction } from \"../helpers/function.mjs\";\nimport DataMap from \"./dataMap.mjs\";\nimport { deepClone } from \"../helpers/object.mjs\";\n/**\n * Loads new data to Handsontable.\n *\n * @private\n * @param {Array} data Array of arrays or array of objects containing data.\n * @param {Function} setDataMapFunction Function that updates the datamap instance.\n * @param {Function} callbackFunction Function that takes care of updating Handsontable to the new dataset. Called\n * right before the `after-` hooks.\n * @param {object} config The configuration object containing all the needed dependency references and information.\n * @param {Handsontable.Core} config.hotInstance The Handsontable instance.\n * @param {DataMap} config.dataMap The current `dataMap` instance.\n * @param {DataSource} config.dataSource The current `dataSource` instance.\n * @param {string} config.internalSource The immediate internal source of the `replaceData` call.\n * @param {string} config.source The source of the call.\n * @param {boolean} config.firstRun `true` if it's a first call in the Handsontable lifecycle, `false` otherwise.\n * @fires Hooks#beforeLoadData\n * @fires Hooks#beforeUpdateData\n * @fires Hooks#afterLoadData\n * @fires Hooks#afterUpdateData\n * @fires Hooks#afterChange\n */\n\nfunction replaceData(data, setDataMapFunction, callbackFunction, config) {\n  var hotInstance = config.hotInstance,\n      dataMap = config.dataMap,\n      dataSource = config.dataSource,\n      internalSource = config.internalSource,\n      source = config.source,\n      firstRun = config.firstRun;\n  var capitalizedInternalSource = toUpperCaseFirst(internalSource);\n  var tableMeta = hotInstance.getSettings();\n\n  if (Array.isArray(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'array';\n  } else if (isFunction(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'function';\n  } else {\n    hotInstance.dataType = 'object';\n  }\n\n  if (dataMap) {\n    dataMap.destroy();\n  }\n\n  data = hotInstance.runHooks(\"before\".concat(capitalizedInternalSource), data, firstRun, source); // TODO: deprecated, will be eventually removed, leaving only the `beforeUpdateData` hook.\n  //  Triggers an additional `afterLoadData` hook for the `updateSettings` calls for backward compatibility.\n\n  if (internalSource !== 'loadData' && source === 'updateSettings') {\n    data = hotInstance.runHooks('beforeLoadData', data, firstRun, source);\n  }\n\n  var newDataMap = new DataMap(hotInstance, data, tableMeta); // We need to apply the new dataMap immediately, because of some asynchronous logic in the\n  // `autoRowSize`/`autoColumnSize` plugins.\n\n  setDataMapFunction(newDataMap);\n\n  if (_typeof(data) === 'object' && data !== null) {\n    if (!(data.push && data.splice)) {\n      // check if data is array. Must use duck-type check so Backbone Collections also pass it\n      // when data is not an array, attempt to make a single-row array of it\n      // eslint-disable-next-line no-param-reassign\n      data = [data];\n    }\n  } else if (data === null) {\n    var dataSchema = newDataMap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n    data = [];\n    var row;\n    var r = 0;\n    var rlen = 0;\n\n    for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {\n      if ((hotInstance.dataType === 'object' || hotInstance.dataType === 'function') && tableMeta.dataSchema) {\n        row = deepClone(dataSchema);\n        data.push(row);\n      } else if (hotInstance.dataType === 'array') {\n        row = deepClone(dataSchema[0]);\n        data.push(row);\n      } else {\n        row = [];\n\n        for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {\n          row.push(null);\n        }\n\n        data.push(row);\n      }\n    }\n  } else {\n    throw new Error(\"\".concat(internalSource, \" only accepts array of objects or array of arrays (\").concat(_typeof(data), \" given)\"));\n  }\n\n  if (Array.isArray(data[0])) {\n    hotInstance.dataType = 'array';\n  }\n\n  tableMeta.data = data;\n  newDataMap.dataSource = data;\n  dataSource.data = data;\n  dataSource.dataType = hotInstance.dataType;\n  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);\n  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);\n  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap); // Run the logic for reassuring that the table structure fits the new dataset.\n\n  callbackFunction(newDataMap);\n  hotInstance.runHooks(\"after\".concat(capitalizedInternalSource), data, firstRun, source); // TODO: deprecated, will be eventually removed, leaving only the `afterUpdateData` hook.\n  //  Triggers an additional `afterLoadData` hook for the `updateSettings` calls for backward compatibility.\n\n  if (internalSource !== 'loadData' && source === 'updateSettings') {\n    hotInstance.runHooks('afterLoadData', data, firstRun, source);\n  } // TODO: rethink the way the `afterChange` hook is being run here in the core `init` method.\n\n\n  if (!firstRun) {\n    // TODO: `afterChange` still needs to provide `loadData` as a `source` when called from `updateSettings` to keep\n    //  backward compatibility - to be changed after removing `loadData`.\n    hotInstance.runHooks('afterChange', null, source === 'updateSettings' ? 'loadData' : internalSource);\n    hotInstance.render();\n  }\n}\n\nexport { replaceData };","map":{"version":3,"sources":["/Users/shehrozkapoor/Desktop/FIRST_CARE/firstcare-frontend/node_modules/handsontable/dataMap/replaceData.mjs"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","toUpperCaseFirst","isFunction","DataMap","deepClone","replaceData","data","setDataMapFunction","callbackFunction","config","hotInstance","dataMap","dataSource","internalSource","source","firstRun","capitalizedInternalSource","tableMeta","getSettings","Array","isArray","dataSchema","dataType","destroy","runHooks","concat","newDataMap","push","splice","getSchema","row","r","rlen","startRows","c","clen","startCols","Error","colToProp","bind","propToCol","countCachedColumns","render"],"mappings":"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","sourcesContent":["import \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nimport { toUpperCaseFirst } from \"../helpers/string.mjs\";\nimport { isFunction } from \"../helpers/function.mjs\";\nimport DataMap from \"./dataMap.mjs\";\nimport { deepClone } from \"../helpers/object.mjs\";\n/**\n * Loads new data to Handsontable.\n *\n * @private\n * @param {Array} data Array of arrays or array of objects containing data.\n * @param {Function} setDataMapFunction Function that updates the datamap instance.\n * @param {Function} callbackFunction Function that takes care of updating Handsontable to the new dataset. Called\n * right before the `after-` hooks.\n * @param {object} config The configuration object containing all the needed dependency references and information.\n * @param {Handsontable.Core} config.hotInstance The Handsontable instance.\n * @param {DataMap} config.dataMap The current `dataMap` instance.\n * @param {DataSource} config.dataSource The current `dataSource` instance.\n * @param {string} config.internalSource The immediate internal source of the `replaceData` call.\n * @param {string} config.source The source of the call.\n * @param {boolean} config.firstRun `true` if it's a first call in the Handsontable lifecycle, `false` otherwise.\n * @fires Hooks#beforeLoadData\n * @fires Hooks#beforeUpdateData\n * @fires Hooks#afterLoadData\n * @fires Hooks#afterUpdateData\n * @fires Hooks#afterChange\n */\n\nfunction replaceData(data, setDataMapFunction, callbackFunction, config) {\n  var hotInstance = config.hotInstance,\n      dataMap = config.dataMap,\n      dataSource = config.dataSource,\n      internalSource = config.internalSource,\n      source = config.source,\n      firstRun = config.firstRun;\n  var capitalizedInternalSource = toUpperCaseFirst(internalSource);\n  var tableMeta = hotInstance.getSettings();\n\n  if (Array.isArray(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'array';\n  } else if (isFunction(tableMeta.dataSchema)) {\n    hotInstance.dataType = 'function';\n  } else {\n    hotInstance.dataType = 'object';\n  }\n\n  if (dataMap) {\n    dataMap.destroy();\n  }\n\n  data = hotInstance.runHooks(\"before\".concat(capitalizedInternalSource), data, firstRun, source); // TODO: deprecated, will be eventually removed, leaving only the `beforeUpdateData` hook.\n  //  Triggers an additional `afterLoadData` hook for the `updateSettings` calls for backward compatibility.\n\n  if (internalSource !== 'loadData' && source === 'updateSettings') {\n    data = hotInstance.runHooks('beforeLoadData', data, firstRun, source);\n  }\n\n  var newDataMap = new DataMap(hotInstance, data, tableMeta); // We need to apply the new dataMap immediately, because of some asynchronous logic in the\n  // `autoRowSize`/`autoColumnSize` plugins.\n\n  setDataMapFunction(newDataMap);\n\n  if (_typeof(data) === 'object' && data !== null) {\n    if (!(data.push && data.splice)) {\n      // check if data is array. Must use duck-type check so Backbone Collections also pass it\n      // when data is not an array, attempt to make a single-row array of it\n      // eslint-disable-next-line no-param-reassign\n      data = [data];\n    }\n  } else if (data === null) {\n    var dataSchema = newDataMap.getSchema(); // eslint-disable-next-line no-param-reassign\n\n    data = [];\n    var row;\n    var r = 0;\n    var rlen = 0;\n\n    for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {\n      if ((hotInstance.dataType === 'object' || hotInstance.dataType === 'function') && tableMeta.dataSchema) {\n        row = deepClone(dataSchema);\n        data.push(row);\n      } else if (hotInstance.dataType === 'array') {\n        row = deepClone(dataSchema[0]);\n        data.push(row);\n      } else {\n        row = [];\n\n        for (var c = 0, clen = tableMeta.startCols; c < clen; c++) {\n          row.push(null);\n        }\n\n        data.push(row);\n      }\n    }\n  } else {\n    throw new Error(\"\".concat(internalSource, \" only accepts array of objects or array of arrays (\").concat(_typeof(data), \" given)\"));\n  }\n\n  if (Array.isArray(data[0])) {\n    hotInstance.dataType = 'array';\n  }\n\n  tableMeta.data = data;\n  newDataMap.dataSource = data;\n  dataSource.data = data;\n  dataSource.dataType = hotInstance.dataType;\n  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);\n  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);\n  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap); // Run the logic for reassuring that the table structure fits the new dataset.\n\n  callbackFunction(newDataMap);\n  hotInstance.runHooks(\"after\".concat(capitalizedInternalSource), data, firstRun, source); // TODO: deprecated, will be eventually removed, leaving only the `afterUpdateData` hook.\n  //  Triggers an additional `afterLoadData` hook for the `updateSettings` calls for backward compatibility.\n\n  if (internalSource !== 'loadData' && source === 'updateSettings') {\n    hotInstance.runHooks('afterLoadData', data, firstRun, source);\n  } // TODO: rethink the way the `afterChange` hook is being run here in the core `init` method.\n\n\n  if (!firstRun) {\n    // TODO: `afterChange` still needs to provide `loadData` as a `source` when called from `updateSettings` to keep\n    //  backward compatibility - to be changed after removing `loadData`.\n    hotInstance.runHooks('afterChange', null, source === 'updateSettings' ? 'loadData' : internalSource);\n    hotInstance.render();\n  }\n}\n\nexport { replaceData };"]},"metadata":{},"sourceType":"module"}