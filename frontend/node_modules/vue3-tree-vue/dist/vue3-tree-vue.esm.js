import { defineComponent, ref, computed, onMounted, onUnmounted, watch, nextTick, openBlock, createElementBlock, withModifiers, createCommentVNode, createElementVNode, normalizeClass, renderSlot, toDisplayString, withDirectives, withKeys, vModelText, resolveComponent, Fragment, renderList, createVNode, withCtx, normalizeProps, guardReactiveProps, createSlots } from 'vue';

/**
 * This recursive call is used to traverse a folder looking for all children of a particular type
 * @param parent
 * @param expectedType
 * @returns
 */
const cascadeStateToDescendants = (item, state) => {
  var _item$children;

  (_item$children = item.children) === null || _item$children === void 0 ? void 0 : _item$children.forEach(child => {
    child.checkedStatus = item.checkedStatus;
    state.emitItemCheckedChange(child);
    cascadeStateToDescendants(child, state);
  });
};
const notifyParentOfSelection = (child, state) => {
  var _parent$children, _parent$children2, _parent$children3, _parent$children4;

  if (!child) return;
  const parent = state.getParent(child.id);
  if (!parent) return;
  const isEveryChildChecked = (_parent$children = parent.children) === null || _parent$children === void 0 ? void 0 : _parent$children.every(child => child.checkedStatus == 'true');
  const hasIntermediate = (_parent$children2 = parent.children) === null || _parent$children2 === void 0 ? void 0 : _parent$children2.some(child => child.checkedStatus == 'indeterminate');
  const hasAnUncheckedChild = (_parent$children3 = parent.children) === null || _parent$children3 === void 0 ? void 0 : _parent$children3.some(child => child.checkedStatus == 'false' || !child.checkedStatus);
  const hasACheckedChild = (_parent$children4 = parent.children) === null || _parent$children4 === void 0 ? void 0 : _parent$children4.some(child => child.checkedStatus == 'true');

  if (isEveryChildChecked) {
    parent.checkedStatus = 'true';
  } else if (hasIntermediate || hasAnUncheckedChild && hasACheckedChild) {
    parent.checkedStatus = 'indeterminate';
  } else {
    parent.checkedStatus = 'false';
  }

  state.emitItemCheckedChange(parent);
  notifyParentOfSelection(parent, state);
};

var script$1 = defineComponent({
  inheritAttrs: true,
  props: {
    item: {
      type: Object,
      required: true
    },
    isCheckable: {
      type: Boolean
    },
    canRename: {
      type: Boolean
    },
    selectedItem: {
      type: Object
    },
    treeState: {
      type: Object
    }
  },
  emits: ["on-rename", "onContextMenu"],

  setup(props, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    const checkbox = ref();
    const isSelected = computed(() => {
      var _props$selectedItem;

      return ((_props$selectedItem = props.selectedItem) === null || _props$selectedItem === void 0 ? void 0 : _props$selectedItem.id) == props.item.id;
    });
    const parent = computed(() => attrs.parent);
    onMounted(() => {
      var _props$treeState, _props$treeState2;

      (_props$treeState = props.treeState) === null || _props$treeState === void 0 ? void 0 : _props$treeState.trackNode(props.item, parent.value);

      if ((_props$treeState2 = props.treeState) !== null && _props$treeState2 !== void 0 && _props$treeState2.isNodeExpanded(props.item.id, props.item.type)) {
        toggleExpand();
      }
    });
    onUnmounted(() => {
      var _props$treeState3;

      return (_props$treeState3 = props.treeState) === null || _props$treeState3 === void 0 ? void 0 : _props$treeState3.untrackNode(props.item);
    });

    const updateCheckState = () => {
      var _checkbox$value;

      props.item.checkedStatus = ((_checkbox$value = checkbox.value) === null || _checkbox$value === void 0 ? void 0 : _checkbox$value.checked) == true ? 'true' : 'false';
      props.treeState.emitItemCheckedChange(props.item);
      notifyParentOfSelection(props.item, props.treeState);
      cascadeStateToDescendants(props.item, props.treeState);
    };

    watch(() => props.item.checkedStatus, () => {
      if (props.item.checkedStatus == 'indeterminate') {
        checkbox.value.indeterminate = true;
      } else {
        checkbox.value.indeterminate = false;
        checkbox.value.checked = props.item.checkedStatus == 'true' ? true : false;
      }
    });
    const isRenaming = ref(false);
    const renameBox = ref();

    const beginRenaming = () => {
      if (!props.canRename) return;
      isRenaming.value = true;
      nextTick().then(() => {
        var _renameBox$value;

        return (_renameBox$value = renameBox.value) === null || _renameBox$value === void 0 ? void 0 : _renameBox$value.focus();
      });
    };

    const finishRenaming = () => {
      // v-on:blur and key(enter) can cause this to fire twice.
      // this check protects against that.
      if (!isRenaming) return;
      emit("on-rename", props.item);
    };

    const chevron = ref();

    const toggleExpand = () => {
      var _chevron$value, _document$getElementB;

      (_chevron$value = chevron.value) === null || _chevron$value === void 0 ? void 0 : _chevron$value.classList.toggle("rotate-90");
      const element = (_document$getElementB = document.getElementById(props.item.id)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.getElementsByClassName('node-child');
      if (!element || !element[0]) return;
      element[0].classList.toggle('hide');
    };

    return {
      toggleExpand,
      chevron,
      isSelected,
      updateCheckState,
      isRenaming,
      beginRenaming,
      finishRenaming,
      parent,
      checkbox
    };
  }

});

const _hoisted_1$1 = {
  key: 0,
  class: "horizontal-dashes"
};
const _hoisted_2$1 = {
  key: 0,
  style: {
    "display": "flex"
  }
};
const _hoisted_3 = {
  class: "d-flex",
  style: {
    "margin-left": "0.4em",
    "margin-right": "0.4em"
  }
};
const _hoisted_4 = {
  key: 0,
  for: "checkbox"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "d-flex align-items-center",
    onContextmenu: _cache[8] || (_cache[8] = withModifiers($event => _ctx.$emit('onContextMenu', {
      item: _ctx.item,
      event: $event
    }), ["prevent"]))
  }, [_ctx.$attrs.isNested ? (openBlock(), createElementBlock("div", _hoisted_1$1)) : createCommentVNode("", true), createElementVNode("span", {
    class: normalizeClass(["chevron-right", {
      'hide-chevron': !_ctx.item.children || _ctx.item.children.length < 1
    }]),
    ref: "chevron",
    onClick: _cache[0] || (_cache[0] = $event => _ctx.toggleExpand())
  }, null, 2), createElementVNode("div", {
    class: normalizeClass(["pointer", {
      'selected-tree-item': !_ctx.isCheckable && _ctx.isSelected
    }]),
    style: {
      "width": "100%"
    }
  }, [!_ctx.isRenaming ? (openBlock(), createElementBlock("div", {
    key: 0,
    onDblclick: _cache[4] || (_cache[4] = function () {
      return _ctx.beginRenaming && _ctx.beginRenaming(...arguments);
    })
  }, [_ctx.isCheckable ? (openBlock(), createElementBlock("div", _hoisted_2$1, [createElementVNode("input", {
    onContextmenu: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"])),
    onChange: _cache[2] || (_cache[2] = function () {
      return _ctx.updateCheckState && _ctx.updateCheckState(...arguments);
    }),
    type: "checkbox",
    ref: "checkbox"
  }, null, 544), createElementVNode("div", _hoisted_3, [renderSlot(_ctx.$slots, "icon"), renderSlot(_ctx.$slots, "prepend")]), !_ctx.isRenaming ? (openBlock(), createElementBlock("label", _hoisted_4, toDisplayString(_ctx.item.name), 1)) : createCommentVNode("", true)])) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: "d-flex",
    onClick: _cache[3] || (_cache[3] = $event => {
      var _ctx$treeState;

      return (_ctx$treeState = _ctx.treeState) === null || _ctx$treeState === void 0 ? void 0 : _ctx$treeState.emitItemSelected(_ctx.item);
    })
  }, [renderSlot(_ctx.$slots, "icon"), renderSlot(_ctx.$slots, "prepend"), createElementVNode("span", null, toDisplayString(_ctx.item.name), 1)]))], 32)) : withDirectives((openBlock(), createElementBlock("input", {
    key: 1,
    ref: "rename-box",
    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.item.name = $event),
    onKeyup: _cache[6] || (_cache[6] = withKeys(function () {
      return _ctx.finishRenaming && _ctx.finishRenaming(...arguments);
    }, ["enter"])),
    onBlur: _cache[7] || (_cache[7] = function () {
      return _ctx.finishRenaming && _ctx.finishRenaming(...arguments);
    })
  }, null, 544)), [[vModelText, _ctx.item.name]])], 2)], 32);
}

script$1.render = render$1;

function useTreeViewItemMouseActions() {
  const addHoverClass = event => {
    const target = event.currentTarget;

    if (target) {
      target.classList.add('drag-over');
    }
  };

  const removeHoverClass = event => {
    const target = event.currentTarget;

    if (target) {
      target.classList.remove('drag-over');
    }
  };

  const onDragNode = (item, event) => {
    if (event.dataTransfer) {
      event.dataTransfer.setData('text/plain', JSON.stringify(item));
    }
  };

  const onDropNode = (dropHost, event, isDropValid) => {
    if (event.dataTransfer) {
      const droppedNode = JSON.parse(event.dataTransfer.getData('text/plain'));
      removeHoverClass(event);

      if (droppedNode.id === dropHost.id) {
        return;
      }

      if (!isDropValid(droppedNode, dropHost)) return;
    }
  };

  return {
    addHoverClass,
    removeHoverClass,
    onDragNode,
    onDropNode
  };
}

/**
 * Initialises the root state of a tree.
 * @param selectedItem An array of preselected items
 * @param onItemSelected Callback for itemselected
 * @param checkedItems An array of prechecked items
 * @param onItemsChecked Callback for itemChecked
 * @param isNodeExpanded A callback to verify if node is preset to expanded
 * @param itemSelectedEventHandler A callback when an item is selected.
 * @param itemSelectedEventHandler A callback when an item is checked.
 * @returns
 */
function useGraph(selectedItem, onItemSelected, checkedItems, onItemsChecked, isNodeExpanded, itemSelectedEventHandler, itemCheckedEventHandler) {
  const childParentLookUp = {};

  const getParent = childId => childParentLookUp[childId];

  const trackNode = (node, parentNode) => childParentLookUp[node.id] = parentNode;

  const untrackNode = node => delete childParentLookUp[node.id];

  const checkedItemsLookup = {};
  checkedItems === null || checkedItems === void 0 ? void 0 : checkedItems.forEach(node => checkedItemsLookup[node.id] = node);

  const emitItemSelected = node => {
    if (node === selectedItem) return;
    itemSelectedEventHandler({
      item: node,
      change: 'selected'
    });
    selectedItem = node;
    onItemSelected(node);
  };

  const emitItemCheckedChange = node => {
    itemCheckedEventHandler({
      item: node,
      change: node.checkedStatus
    });
    if (node.checkedStatus == 'true') checkedItemsLookup[node.id] = node;else delete checkedItemsLookup[node.id];
    onItemsChecked(Object.values(checkedItemsLookup));
  };

  return {
    getParent,
    trackNode,
    untrackNode,
    emitItemCheckedChange,
    emitItemSelected,
    isNodeExpanded
  };
}

var script = defineComponent({
  name: 'tree-view',
  props: {
    items: {
      type: Array,
      required: true,
      default: () => {
        return [];
      }
    },
    selectedItem: {
      type: Object
    },
    checkedItems: {
      type: Array
    },
    isCheckable: {
      type: Boolean
    },
    hideGuideLines: {
      type: Boolean,
      default: false
    },
    onDropValidator: {
      type: Function,
      default: () => {
      }
    },
    treeState: {
      type: Object
    },
    expandedTypes: {
      type: Object,
      default: () => []
    },
    expandedIds: {
      type: Object,
      default: () => []
    },
    expandAll: {
      type: Boolean,
      default: false
    }
  },
  components: {
    'treeview-item': script$1
  },
  emits: ['update:selectedItem', 'update:checkedItems', 'onContextMenu', 'onSelect', 'onCheck'],

  setup(props, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    const parent = computed(() => attrs.parent);
    const treeState = ref();
    var expandedKeys = new Set([...props.expandedTypes, ...props.expandedIds]); // Create a tree state object for only root nodes.

    if (props.treeState != null) {
      treeState.value = props.treeState;
    } else {
      treeState.value = useGraph(props.selectedItem, selectedItem => emit('update:selectedItem', selectedItem), props.checkedItems, checkedItems => emit('update:checkedItems', checkedItems), (id, type) => expandedKeys.has(id) || expandedKeys.has(type) || props.expandAll, eventArguments => emit('onSelect', eventArguments), eventArguments => emit('onCheck', eventArguments));
    }

    return { ...useTreeViewItemMouseActions(),
      parent,
      treeState
    };
  }

});

const _hoisted_1 = {
  id: "explorer",
  class: "explorer tree-item-node-parent"
};
const _hoisted_2 = ["id", "onDragstart", "onDrop"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_treeview_item = resolveComponent("treeview-item");

  const _component_tree_view = resolveComponent("tree-view");

  return openBlock(), createElementBlock("ul", _hoisted_1, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, treeViewItem => {
    return openBlock(), createElementBlock("li", {
      key: treeViewItem.id,
      id: treeViewItem.id,
      draggable: "",
      onDragover: [_cache[1] || (_cache[1] = withModifiers(() => {}, ["stop", "prevent"])), _cache[3] || (_cache[3] = withModifiers(function () {
        return _ctx.addHoverClass && _ctx.addHoverClass(...arguments);
      }, ["stop"]))],
      onDragenter: _cache[2] || (_cache[2] = withModifiers(() => {}, ["stop", "prevent"])),
      onDragstart: withModifiers($event => _ctx.onDragNode(treeViewItem, $event), ["stop"]),
      onDrop: withModifiers($event => _ctx.onDropNode(treeViewItem, $event, _ctx.onDropValidator), ["prevent", "stop"]),
      class: "tree-item-node",
      onDragleave: _cache[4] || (_cache[4] = withModifiers(function () {
        return _ctx.removeHoverClass && _ctx.removeHoverClass(...arguments);
      }, ["stop"]))
    }, [createVNode(_component_treeview_item, {
      class: "pointer tree-view-item",
      item: treeViewItem,
      parent: _ctx.parent,
      isCheckable: _ctx.isCheckable,
      selectedItem: _ctx.selectedItem,
      treeState: _ctx.treeState,
      onContextmenu: withModifiers($event => _ctx.$emit('onContextMenu', {
        item: treeViewItem,
        event: $event
      }), ["prevent"])
    }, {
      icon: withCtx(() => [renderSlot(_ctx.$slots, "item-prepend-icon", normalizeProps(guardReactiveProps(treeViewItem)))]),
      prepend: withCtx(() => [renderSlot(_ctx.$slots, "item-prepend", normalizeProps(guardReactiveProps(treeViewItem)))]),
      _: 2
    }, 1032, ["item", "parent", "isCheckable", "selectedItem", "treeState", "onContextmenu"]), treeViewItem.children && treeViewItem.children.length > 0 ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["node-child hide", {
        'hide-guidelines': _ctx.hideGuideLines
      }])
    }, [createVNode(_component_tree_view, {
      items: treeViewItem.children,
      hideGuideLines: _ctx.hideGuideLines,
      isNested: true,
      parent: treeViewItem,
      selectedItem: _ctx.selectedItem,
      checkedItems: _ctx.checkedItems,
      treeState: _ctx.treeState,
      isCheckable: _ctx.isCheckable,
      onOnContextMenu: _cache[0] || (_cache[0] = $event => _ctx.$emit('onContextMenu', $event))
    }, createSlots({
      _: 2
    }, [renderList(_ctx.$slots, (_, slot) => {
      return {
        name: slot,
        fn: withCtx(props => [renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(props)))])
      };
    })]), 1032, ["items", "hideGuideLines", "parent", "selectedItem", "checkedItems", "treeState", "isCheckable"])], 2)) : createCommentVNode("", true)], 40, _hoisted_2);
  }), 128))]);
}

script.render = render;

var entry_esm = (() => {
  const installable = script;

  installable.install = app => {
    app.component('vue3-tree-vue', installable);
  };

  return installable;
})();

export { entry_esm as default };
