import { Chart, BarController, DoughnutController, LineController, PieController, PolarAreaController, RadarController, BubbleController, ScatterController } from 'chart.js';

var ChartEmits;
(function(ChartEmits) {
    ChartEmits["ChartRendered"] = 'chart:rendered';
    ChartEmits["ChartUpdated"] = 'chart:updated';
    ChartEmits["ChartDestroyed"] = 'chart:destroyed';
    ChartEmits["LabelsUpdated"] = 'labels:updated';
})(ChartEmits || (ChartEmits = {}));
function chartCreate(createChartFunction, chartData, chartOptions, context) {
    createChartFunction(chartData, chartOptions);
    if (context !== undefined) {
        context.emit(ChartEmits.ChartRendered);
    }
}
function chartUpdate(chart, context) {
    chart.update();
    if (context !== undefined) {
        context.emit(ChartEmits.ChartUpdated);
    }
}
function chartDestroy(chart, context) {
    chart.destroy();
    if (context !== undefined) {
        context.emit(ChartEmits.ChartDestroyed);
    }
}
function getChartData(data, datasetIdKey) {
    const nextData = {
        labels: typeof data.labels === 'undefined' ? [] : [
            ...data.labels
        ],
        datasets: []
    };
    setChartDatasets(nextData, {
        ...data
    }, datasetIdKey);
    return nextData;
}
function setChartDatasets(oldData, newData, datasetIdKey) {
    const addedDatasets = [];
    oldData.datasets = newData.datasets.map((nextDataset)=>{
        // given the new set, find it's current match
        const currentDataset = oldData.datasets.find((dataset)=>dataset[datasetIdKey] === nextDataset[datasetIdKey]
        );
        // There is no original to update, so simply add new one
        if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
            return {
                ...nextDataset
            };
        }
        addedDatasets.push(currentDataset);
        Object.assign(currentDataset, nextDataset);
        return currentDataset;
    });
}
function setChartLabels(chart, labels, context) {
    chart.data.labels = labels;
    if (context !== undefined) {
        context.emit(ChartEmits.LabelsUpdated);
    }
}
function compareData(newData, oldData) {
    // Get new and old DataSet Labels
    const newDatasetLabels = newData.datasets.map((dataset)=>{
        return dataset.label;
    });
    const oldDatasetLabels = oldData.datasets.map((dataset)=>{
        return dataset.label;
    });
    // Check if Labels are equal and if dataset length is equal
    return oldData.datasets.length === newData.datasets.length && newDatasetLabels.every((value, index)=>value === oldDatasetLabels[index]
    );
}
const templateError = 'Please remove the <template></template> tags from your chart component. See https://vue-chartjs.org/guide/#vue-single-file-components';

function generateChart(chartId, chartType, chartController) {
    let _chartRef = null;
    return {
        props: {
            chartData: {
                type: Object,
                required: true
            },
            chartOptions: {
                type: Object,
                default: ()=>{}
            },
            datasetIdKey: {
                type: String,
                default: 'label'
            },
            chartId: {
                type: String,
                default: chartId
            },
            width: {
                type: Number,
                default: 400
            },
            height: {
                type: Number,
                default: 400
            },
            cssClasses: {
                type: String,
                default: ''
            },
            styles: {
                type: Object,
                default: ()=>{}
            },
            plugins: {
                type: Array,
                default: ()=>[]
            }
        },
        created () {
            Chart.register(chartController);
        },
        mounted () {
            _chartRef = {
                current: null
            };
            if ('datasets' in this.chartData && this.chartData.datasets.length > 0) {
                chartCreate(this.renderChart, this.chartData, this.chartOptions);
                this.$emit(ChartEmits.ChartRendered);
            }
        },
        watch: {
            chartData (newValue, oldValue) {
                this.chartDataHandler(newValue, oldValue);
            }
        },
        methods: {
            renderChart (data, options) {
                if ((_chartRef === null || _chartRef === void 0 ? void 0 : _chartRef.current) !== null) {
                    chartDestroy(_chartRef.current);
                    this.$emit(ChartEmits.ChartDestroyed);
                }
                if (!this.$refs.canvas) {
                    throw new Error(templateError);
                } else {
                    const chartData = getChartData(data, this.datasetIdKey);
                    const canvasEl2DContext = this.$refs.canvas.getContext('2d');
                    if (canvasEl2DContext !== null) {
                        _chartRef.current = new Chart(canvasEl2DContext, {
                            type: chartType,
                            data: chartData,
                            options,
                            plugins: this.plugins
                        });
                    }
                }
            },
            chartDataHandler (newValue, oldValue) {
                const newData = {
                    ...newValue
                };
                const oldData = {
                    ...oldValue
                };
                if (Object.keys(oldData).length > 0) {
                    const isEqualLabelsAndDatasetsLength = compareData(newData, oldData);
                    if (isEqualLabelsAndDatasetsLength && (_chartRef === null || _chartRef === void 0 ? void 0 : _chartRef.current) !== null) {
                        setChartDatasets(_chartRef.current.data, newData, this.datasetIdKey);
                        if (newData.labels !== undefined) {
                            setChartLabels(_chartRef.current, newData.labels);
                            this.$emit(ChartEmits.LabelsUpdated);
                        }
                        chartUpdate(_chartRef.current);
                        this.$emit(ChartEmits.ChartUpdated);
                    } else {
                        if ((_chartRef === null || _chartRef === void 0 ? void 0 : _chartRef.current) !== null) {
                            chartDestroy(_chartRef.currentt);
                            this.$emit(ChartEmits.ChartDestroyed);
                        }
                        chartCreate(this.renderChart, this.chartData, this.chartOptions);
                        this.$emit(ChartEmits.ChartRendered);
                    }
                } else {
                    if ((_chartRef === null || _chartRef === void 0 ? void 0 : _chartRef.current) !== null) {
                        chartDestroy(_chartRef.current);
                        this.$emit(ChartEmits.ChartDestroyed);
                    }
                    chartCreate(this.renderChart, this.chartData, this.chartOptions);
                    this.$emit(ChartEmits.ChartRendered);
                }
            }
        },
        beforeDestroy () {
            if ((_chartRef === null || _chartRef === void 0 ? void 0 : _chartRef.current) !== null) {
                chartDestroy(_chartRef.current);
                this.$emit(ChartEmits.ChartDestroyed);
            }
        },
        render: function(createElement) {
            return createElement('div', {
                style: this.styles,
                class: this.cssClasses
            }, [
                createElement('canvas', {
                    attrs: {
                        id: this.chartId,
                        width: this.width,
                        height: this.height
                    },
                    ref: 'canvas'
                })
            ]);
        }
    };
}
const Bar = /* #__PURE__ */ generateChart('bar-chart', 'bar', BarController);
const Doughnut = /* #__PURE__ */ generateChart('doughnut-chart', 'doughnut', DoughnutController);
const Line = /* #__PURE__ */ generateChart('line-chart', 'line', LineController);
const Pie = /* #__PURE__ */ generateChart('pie-chart', 'pie', PieController);
const PolarArea = /* #__PURE__ */ generateChart('polar-chart', 'polarArea', PolarAreaController);
const Radar = /* #__PURE__ */ generateChart('radar-chart', 'radar', RadarController);
const Bubble = /* #__PURE__ */ generateChart('bubble-chart', 'bubble', BubbleController);
const Scatter = /* #__PURE__ */ generateChart('scatter-chart', 'scatter', ScatterController);

export { Bar, Bubble, Doughnut, Line, Pie, PolarArea, Radar, Scatter, generateChart };
//# sourceMappingURL=index.js.map
