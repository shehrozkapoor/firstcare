function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

import "core-js/modules/es.object.assign.js";
import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";

/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
import { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';
import { ErrorMessage } from './error-message';
import { EmptyValue, getFormatOfExtendedNumber, getTypeOfExtendedNumber, isExtendedNumber, NumberType } from './interpreter/InterpreterValue';
import { SimpleRangeValue } from './interpreter/SimpleRangeValue';
/**
 * Possible errors returned by our interpreter.
 */

export var ErrorType;

(function (ErrorType) {
  /** Division by zero. */
  ErrorType["DIV_BY_ZERO"] = "DIV_BY_ZERO";
  /** Unknown function name. */

  ErrorType["NAME"] = "NAME";
  ErrorType["VALUE"] = "VALUE";
  ErrorType["NUM"] = "NUM";
  ErrorType["NA"] = "NA";
  /** Cyclic dependency. */

  ErrorType["CYCLE"] = "CYCLE";
  /** Wrong address reference. */

  ErrorType["REF"] = "REF";
  /** Array spill error. */

  ErrorType["SPILL"] = "SPILL";
  /** Invalid/missing licence error. */

  ErrorType["LIC"] = "LIC";
  /** Generic error */

  ErrorType["ERROR"] = "ERROR";
})(ErrorType || (ErrorType = {}));

export var CellType;

(function (CellType) {
  CellType["FORMULA"] = "FORMULA";
  CellType["VALUE"] = "VALUE";
  CellType["ARRAY"] = "ARRAY";
  CellType["EMPTY"] = "EMPTY";
  CellType["ARRAYFORMULA"] = "ARRAYFORMULA";
})(CellType || (CellType = {}));

export var getCellType = function getCellType(vertex, address) {
  if (vertex instanceof ArrayVertex) {
    if (vertex.isLeftCorner(address)) {
      return CellType.ARRAYFORMULA;
    } else {
      return CellType.ARRAY;
    }
  }

  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {
    return CellType.FORMULA;
  }

  if (vertex instanceof ValueCellVertex) {
    return CellType.VALUE;
  }

  return CellType.EMPTY;
};
export var CellValueNoNumber;

(function (CellValueNoNumber) {
  CellValueNoNumber["EMPTY"] = "EMPTY";
  CellValueNoNumber["NUMBER"] = "NUMBER";
  CellValueNoNumber["STRING"] = "STRING";
  CellValueNoNumber["BOOLEAN"] = "BOOLEAN";
  CellValueNoNumber["ERROR"] = "ERROR";
})(CellValueNoNumber || (CellValueNoNumber = {}));

export var CellValueJustNumber;

(function (CellValueJustNumber) {
  CellValueJustNumber["NUMBER"] = "NUMBER";
})(CellValueJustNumber || (CellValueJustNumber = {}));

export var CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);
export var CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);
export var CellValueTypeOrd = function CellValueTypeOrd(arg) {
  switch (arg) {
    case CellValueType.EMPTY:
      return 0;

    case CellValueType.NUMBER:
      return 1;

    case CellValueType.STRING:
      return 2;

    case CellValueType.BOOLEAN:
      return 3;

    case CellValueType.ERROR:
      return 4;
  }

  throw new Error('Cell value not computed');
};
export var getCellValueType = function getCellValueType(cellValue) {
  if (cellValue === EmptyValue) {
    return CellValueType.EMPTY;
  }

  if (cellValue instanceof CellError || cellValue instanceof SimpleRangeValue) {
    return CellValueType.ERROR;
  }

  if (typeof cellValue === 'string') {
    return CellValueType.STRING;
  } else if (isExtendedNumber(cellValue)) {
    return CellValueType.NUMBER;
  } else if (typeof cellValue === 'boolean') {
    return CellValueType.BOOLEAN;
  }

  throw new Error('Cell value not computed');
};
export var getCellValueDetailedType = function getCellValueDetailedType(cellValue) {
  if (isExtendedNumber(cellValue)) {
    return getTypeOfExtendedNumber(cellValue);
  } else {
    return getCellValueType(cellValue);
  }
};
export var getCellValueFormat = function getCellValueFormat(cellValue) {
  if (isExtendedNumber(cellValue)) {
    return getFormatOfExtendedNumber(cellValue);
  } else {
    return undefined;
  }
};
export var CellError = /*#__PURE__*/function () {
  function CellError(type, message, root) {
    _classCallCheck(this, CellError);

    this.type = type;
    this.message = message;
    this.root = root;
  }

  _createClass(CellError, [{
    key: "attachRootVertex",
    value: function attachRootVertex(vertex) {
      if (this.root === undefined) {
        return new CellError(this.type, this.message, vertex);
      } else {
        return this;
      }
    }
  }], [{
    key: "parsingError",
    value: function parsingError() {
      return new CellError(ErrorType.ERROR, ErrorMessage.ParseError);
    }
  }]);

  return CellError;
}();
export var simpleRowAddress = function simpleRowAddress(sheet, row) {
  return {
    sheet: sheet,
    row: row
  };
};
export var invalidSimpleRowAddress = function invalidSimpleRowAddress(address) {
  return address.row < 0;
};
export var simpleColumnAddress = function simpleColumnAddress(sheet, col) {
  return {
    sheet: sheet,
    col: col
  };
};
export var invalidSimpleColumnAddress = function invalidSimpleColumnAddress(address) {
  return address.col < 0;
};
export var simpleCellAddress = function simpleCellAddress(sheet, col, row) {
  return {
    sheet: sheet,
    col: col,
    row: row
  };
};
export var invalidSimpleCellAddress = function invalidSimpleCellAddress(address) {
  return address.col < 0 || address.row < 0;
};
export var movedSimpleCellAddress = function movedSimpleCellAddress(address, toSheet, toRight, toBottom) {
  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);
};
export var addressKey = function addressKey(address) {
  return "".concat(address.sheet, ",").concat(address.row, ",").concat(address.col);
};
export function isSimpleCellAddress(obj) {
  if (obj && (_typeof(obj) === 'object' || typeof obj === 'function')) {
    return 'col' in obj && typeof obj.col === 'number' && 'row' in obj && typeof obj.row === 'number' && 'sheet' in obj && typeof obj.sheet === 'number';
  } else {
    return false;
  }
}
export var absoluteSheetReference = function absoluteSheetReference(address, baseAddress) {
  var _a;

  return (_a = address.sheet) !== null && _a !== void 0 ? _a : baseAddress.sheet;
};
export var equalSimpleCellAddress = function equalSimpleCellAddress(left, right) {
  return left.sheet === right.sheet && left.col === right.col && left.row === right.row;
};