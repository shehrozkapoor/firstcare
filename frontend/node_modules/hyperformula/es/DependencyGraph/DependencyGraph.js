function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

import "regenerator-runtime/runtime.js";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import "core-js/modules/es.array.map.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.set.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.concat.js";
import "core-js/modules/web.dom-collections.for-each.js";
import "core-js/modules/es.array.filter.js";
import "core-js/modules/es.array.from.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.reflect.construct.js";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
import { AbsoluteCellRange, simpleCellRange } from '../AbsoluteCellRange';
import { absolutizeDependencies } from '../absolutizeDependencies';
import { CellError, ErrorType, isSimpleCellAddress, simpleCellAddress } from '../Cell';
import { ContentChanges } from '../ContentChanges';
import { ErrorMessage } from '../error-message';
import { EmptyValue, getRawValue } from '../interpreter/InterpreterValue';
import { SimpleRangeValue } from '../interpreter/SimpleRangeValue';
import { collectDependencies, NamedExpressionDependency } from '../parser';
import { ColumnsSpan, RowsSpan } from '../Span';
import { StatType } from '../statistics';
import { ArrayVertex, EmptyCellVertex, FormulaCellVertex, RangeVertex, ValueCellVertex } from './';
import { AddressMapping } from './AddressMapping/AddressMapping';
import { ArrayMapping } from './ArrayMapping';
import { collectAddressesDependentToRange } from './collectAddressesDependentToRange';
import { FormulaVertex } from './FormulaCellVertex';
import { Graph } from './Graph';
import { RangeMapping } from './RangeMapping';
import { SheetMapping } from './SheetMapping';
export var DependencyGraph = /*#__PURE__*/function () {
  function DependencyGraph(addressMapping, rangeMapping, sheetMapping, arrayMapping, stats, lazilyTransformingAstService, functionRegistry, namedExpressions) {
    var _this = this;

    _classCallCheck(this, DependencyGraph);

    this.addressMapping = addressMapping;
    this.rangeMapping = rangeMapping;
    this.sheetMapping = sheetMapping;
    this.arrayMapping = arrayMapping;
    this.stats = stats;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.changes = ContentChanges.empty();

    this.dependencyQueryAddresses = function (vertex) {
      if (vertex instanceof RangeVertex) {
        return _this.rangeDependencyQuery(vertex).map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              address = _ref2[0],
              _ = _ref2[1];

          return address;
        });
      } else {
        var dependenciesResult = _this.formulaDependencyQuery(vertex);

        if (dependenciesResult !== undefined) {
          var _dependenciesResult = _slicedToArray(dependenciesResult, 2),
              address = _dependenciesResult[0],
              dependencies = _dependenciesResult[1];

          return dependencies.map(function (dependency) {
            if (dependency instanceof NamedExpressionDependency) {
              return _this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet).address;
            } else if (isSimpleCellAddress(dependency)) {
              return dependency;
            } else {
              return simpleCellRange(dependency.start, dependency.end);
            }
          });
        } else {
          return [];
        }
      }
    };

    this.dependencyQueryVertices = function (vertex) {
      if (vertex instanceof RangeVertex) {
        return _this.rangeDependencyQuery(vertex).map(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              _ = _ref4[0],
              v = _ref4[1];

          return v;
        });
      } else {
        var dependenciesResult = _this.formulaDependencyQuery(vertex);

        if (dependenciesResult !== undefined) {
          var _dependenciesResult2 = _slicedToArray(dependenciesResult, 2),
              address = _dependenciesResult2[0],
              dependencies = _dependenciesResult2[1];

          return dependencies.map(function (dependency) {
            if (dependency instanceof AbsoluteCellRange) {
              return _this.rangeMapping.fetchRange(dependency.start, dependency.end);
            } else if (dependency instanceof NamedExpressionDependency) {
              var namedExpression = _this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet);

              return _this.addressMapping.fetchCell(namedExpression.address);
            } else {
              return _this.addressMapping.fetchCell(dependency);
            }
          });
        } else {
          return [];
        }
      }
    };

    this.rangeDependencyQuery = function (vertex) {
      var allDeps = [];

      var _this$rangeMapping$fi = _this.rangeMapping.findSmallerRange(vertex.range),
          smallerRangeVertex = _this$rangeMapping$fi.smallerRangeVertex,
          restRange = _this$rangeMapping$fi.restRange; //checking whether this range was splitted by bruteForce or not


      var range;

      if (smallerRangeVertex !== undefined && _this.graph.adjacentNodes(smallerRangeVertex).has(vertex)) {
        range = restRange;
        allDeps.push([new AbsoluteCellRange(smallerRangeVertex.start, smallerRangeVertex.end), smallerRangeVertex]);
      } else {
        //did we ever need to use full range
        range = vertex.range;
      }

      var _iterator = _createForOfIteratorHelper(range.addresses(_this)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var address = _step.value;

          var cell = _this.addressMapping.getCell(address);

          if (cell instanceof EmptyCellVertex) {
            cell.address = address;
          }

          if (cell !== undefined) {
            allDeps.push([address, cell]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return allDeps;
    };

    this.formulaDependencyQuery = function (vertex) {
      var formula;
      var address;

      if (vertex instanceof FormulaVertex) {
        address = vertex.getAddress(_this.lazilyTransformingAstService);
        formula = vertex.getFormula(_this.lazilyTransformingAstService);
      } else {
        return undefined;
      }

      var deps = collectDependencies(formula, _this.functionRegistry);
      return [address, absolutizeDependencies(deps, address)];
    };

    this.graph = new Graph(this.dependencyQueryVertices);
  }
  /**
   * Invariants:
   * - empty cell has associated EmptyCellVertex if and only if it is a dependency (possibly indirect, through range) to some formula
   */


  _createClass(DependencyGraph, [{
    key: "setFormulaToCell",
    value: function setFormulaToCell(address, ast, dependencies, size, hasVolatileFunction, hasStructuralChangeFunction) {
      var newVertex = FormulaVertex.fromAst(ast, address, size, this.lazilyTransformingAstService.version());
      this.exchangeOrAddFormulaVertex(newVertex);
      this.processCellDependencies(dependencies, newVertex);
      this.graph.markNodeAsSpecialRecentlyChanged(newVertex);

      if (hasVolatileFunction) {
        this.markAsVolatile(newVertex);
      }

      if (hasStructuralChangeFunction) {
        this.markAsDependentOnStructureChange(newVertex);
      }

      this.correctInfiniteRangesDependency(address);
      return this.getAndClearContentChanges();
    }
  }, {
    key: "setParsingErrorToCell",
    value: function setParsingErrorToCell(address, errorVertex) {
      var vertex = this.shrinkPossibleArrayAndGetCell(address);
      this.exchangeOrAddGraphNode(vertex, errorVertex);
      this.addressMapping.setCell(address, errorVertex);
      this.graph.markNodeAsSpecialRecentlyChanged(errorVertex);
      this.correctInfiniteRangesDependency(address);
      return this.getAndClearContentChanges();
    }
  }, {
    key: "setValueToCell",
    value: function setValueToCell(address, value) {
      var vertex = this.shrinkPossibleArrayAndGetCell(address);

      if (vertex instanceof ArrayVertex) {
        this.arrayMapping.removeArray(vertex.getRange());
      }

      if (vertex instanceof ValueCellVertex) {
        var oldValues = vertex.getValues();

        if (oldValues.rawValue !== value.rawValue) {
          vertex.setValues(value);
          this.graph.markNodeAsSpecialRecentlyChanged(vertex);
        }
      } else {
        var newVertex = new ValueCellVertex(value.parsedValue, value.rawValue);
        this.exchangeOrAddGraphNode(vertex, newVertex);
        this.addressMapping.setCell(address, newVertex);
        this.graph.markNodeAsSpecialRecentlyChanged(newVertex);
      }

      this.correctInfiniteRangesDependency(address);
      return this.getAndClearContentChanges();
    }
  }, {
    key: "setCellEmpty",
    value: function setCellEmpty(address) {
      var vertex = this.shrinkPossibleArrayAndGetCell(address);

      if (vertex === undefined) {
        return ContentChanges.empty();
      }

      if (this.graph.adjacentNodes(vertex).size > 0) {
        var emptyVertex = new EmptyCellVertex(address);
        this.exchangeGraphNode(vertex, emptyVertex);

        if (this.graph.adjacentNodesCount(emptyVertex) === 0) {
          this.removeVertex(emptyVertex);
          this.addressMapping.removeCell(address);
        } else {
          this.graph.markNodeAsSpecialRecentlyChanged(emptyVertex);
          this.addressMapping.setCell(address, emptyVertex);
        }
      } else {
        this.removeVertex(vertex);
        this.addressMapping.removeCell(address);
      }

      return this.getAndClearContentChanges();
    }
  }, {
    key: "ensureThatVertexIsNonArrayCellVertex",
    value: function ensureThatVertexIsNonArrayCellVertex(vertex) {
      if (vertex instanceof ArrayVertex) {
        throw new Error('Illegal operation');
      }
    }
  }, {
    key: "clearRecentlyChangedVertices",
    value: function clearRecentlyChangedVertices() {
      this.graph.clearSpecialNodesRecentlyChanged();
    }
  }, {
    key: "verticesToRecompute",
    value: function verticesToRecompute() {
      return new Set([].concat(_toConsumableArray(this.graph.specialNodesRecentlyChanged), _toConsumableArray(this.volatileVertices())));
    }
  }, {
    key: "processCellDependencies",
    value: function processCellDependencies(cellDependencies, endVertex) {
      var _this2 = this;

      cellDependencies.forEach(function (dep) {
        if (dep instanceof AbsoluteCellRange) {
          var range = dep;

          var rangeVertex = _this2.getRange(range.start, range.end);

          if (rangeVertex === undefined) {
            rangeVertex = new RangeVertex(range);

            _this2.rangeMapping.setRange(rangeVertex);
          }

          _this2.graph.addNode(rangeVertex);

          if (!range.isFinite()) {
            _this2.graph.markNodeAsInfiniteRange(rangeVertex);
          }

          var _this2$rangeMapping$f = _this2.rangeMapping.findSmallerRange(range),
              smallerRangeVertex = _this2$rangeMapping$f.smallerRangeVertex,
              restRange = _this2$rangeMapping$f.restRange;

          if (smallerRangeVertex !== undefined) {
            _this2.graph.addEdge(smallerRangeVertex, rangeVertex);

            if (rangeVertex.bruteForce) {
              rangeVertex.bruteForce = false;

              var _iterator2 = _createForOfIteratorHelper(range.addresses(_this2)),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var cellFromRange = _step2.value;

                  //if we ever switch heuristic to processing by sorted sizes, this would be unnecessary
                  _this2.graph.removeEdge(_this2.fetchCell(cellFromRange), rangeVertex);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          } else {
            rangeVertex.bruteForce = true;
          }

          var array = _this2.arrayMapping.getArray(restRange);

          if (array !== undefined) {
            _this2.graph.addEdge(array, rangeVertex);
          } else {
            var _iterator3 = _createForOfIteratorHelper(restRange.addresses(_this2)),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _cellFromRange = _step3.value;

                _this2.graph.addEdge(_this2.fetchCellOrCreateEmpty(_cellFromRange), rangeVertex);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }

          _this2.graph.addEdge(rangeVertex, endVertex);

          if (range.isFinite()) {
            _this2.correctInfiniteRangesDependenciesByRangeVertex(rangeVertex);
          }
        } else if (dep instanceof NamedExpressionDependency) {
          var sheetOfVertex = endVertex.getAddress(_this2.lazilyTransformingAstService).sheet;

          var namedExpressionVertex = _this2.fetchNamedExpressionVertex(dep.name, sheetOfVertex);

          _this2.graph.addEdge(namedExpressionVertex, endVertex);
        } else {
          _this2.graph.addEdge(_this2.fetchCellOrCreateEmpty(dep), endVertex);
        }
      });
    }
  }, {
    key: "fetchNamedExpressionVertex",
    value: function fetchNamedExpressionVertex(expressionName, sheetId) {
      var namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(expressionName, sheetId);
      return this.fetchCellOrCreateEmpty(namedExpression.address);
    }
  }, {
    key: "exchangeNode",
    value: function exchangeNode(addressFrom, addressTo) {
      var vertexFrom = this.fetchCellOrCreateEmpty(addressFrom);
      var vertexTo = this.fetchCellOrCreateEmpty(addressTo);
      this.addressMapping.removeCell(addressFrom);
      this.exchangeGraphNode(vertexFrom, vertexTo);
    }
  }, {
    key: "correctInfiniteRangesDependency",
    value: function correctInfiniteRangesDependency(address) {
      var vertex = undefined;

      var _iterator4 = _createForOfIteratorHelper(this.graph.infiniteRanges),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var range = _step4.value;
          var infiniteRangeVertex = range;

          if (infiniteRangeVertex.range.addressInRange(address)) {
            vertex = vertex !== null && vertex !== void 0 ? vertex : this.fetchCellOrCreateEmpty(address);
            this.graph.addEdge(vertex, infiniteRangeVertex);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "fetchCellOrCreateEmpty",
    value: function fetchCellOrCreateEmpty(address) {
      var vertex = this.addressMapping.getCell(address);

      if (vertex === undefined) {
        vertex = new EmptyCellVertex(address);
        this.graph.addNode(vertex);
        this.addressMapping.setCell(address, vertex);
      }

      return vertex;
    }
  }, {
    key: "removeRows",
    value: function removeRows(removedRows) {
      var _this3 = this;

      this.stats.measure(StatType.ADJUSTING_GRAPH, function () {
        var _iterator5 = _createForOfIteratorHelper(_this3.addressMapping.entriesFromRowsSpan(removedRows)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                address = _step5$value[0],
                vertex = _step5$value[1];

            var _iterator6 = _createForOfIteratorHelper(_this3.graph.adjacentNodes(vertex)),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var adjacentNode = _step6.value;

                _this3.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            if (vertex instanceof ArrayVertex) {
              if (vertex.isLeftCorner(address)) {
                _this3.shrinkArrayToCorner(vertex);

                _this3.arrayMapping.removeArray(vertex.getRange());
              } else {
                continue;
              }
            }

            _this3.removeVertex(vertex);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      });
      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, function () {
        _this3.addressMapping.removeRows(removedRows);
      });
      var affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, function () {
        var affectedRanges = _this3.truncateRanges(removedRows, function (address) {
          return address.row;
        });

        return _this3.getArrayVerticesRelatedToRanges(affectedRanges);
      });
      this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, function () {
        _this3.fixArraysAfterRemovingRows(removedRows.sheet, removedRows.rowStart, removedRows.numberOfRows);
      });
      this.addStructuralNodesToChangeSet();
      return {
        affectedArrays: affectedArrays,
        contentChanges: this.getAndClearContentChanges()
      };
    }
  }, {
    key: "removeSheet",
    value: function removeSheet(removedSheetId) {
      var _this4 = this;

      var arrays = new Set();

      var _iterator7 = _createForOfIteratorHelper(this.addressMapping.sheetEntries(removedSheetId)),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _step7$value = _slicedToArray(_step7.value, 2),
              adr = _step7$value[0],
              vertex = _step7$value[1];

          if (vertex instanceof ArrayVertex) {
            if (arrays.has(vertex)) {
              continue;
            } else {
              arrays.add(vertex);
            }
          }

          var _iterator10 = _createForOfIteratorHelper(this.graph.adjacentNodes(vertex)),
              _step10;

          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              var adjacentNode = _step10.value;
              this.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }

          this.removeVertex(vertex);
          this.addressMapping.removeCell(adr);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, function () {
        var _iterator8 = _createForOfIteratorHelper(arrays.values()),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var array = _step8.value;

            _this4.arrayMapping.removeArray(array.getRange());
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      });
      this.stats.measure(StatType.ADJUSTING_RANGES, function () {
        var rangesToRemove = _this4.rangeMapping.removeRangesInSheet(removedSheetId);

        var _iterator9 = _createForOfIteratorHelper(rangesToRemove),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var range = _step9.value;

            _this4.removeVertex(range);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        _this4.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, function () {
          _this4.addressMapping.removeSheet(removedSheetId);
        });
      });
      this.addStructuralNodesToChangeSet();
    }
  }, {
    key: "clearSheet",
    value: function clearSheet(sheetId) {
      var arrays = new Set();

      var _iterator11 = _createForOfIteratorHelper(this.addressMapping.sheetEntries(sheetId)),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _step11$value = _slicedToArray(_step11.value, 2),
              address = _step11$value[0],
              vertex = _step11$value[1];

          if (vertex instanceof ArrayVertex) {
            arrays.add(vertex);
          } else {
            this.setCellEmpty(address);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      var _iterator12 = _createForOfIteratorHelper(arrays.values()),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var array = _step12.value;
          this.setArrayEmpty(array);
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      this.addStructuralNodesToChangeSet();
    }
  }, {
    key: "removeColumns",
    value: function removeColumns(removedColumns) {
      var _this5 = this;

      this.stats.measure(StatType.ADJUSTING_GRAPH, function () {
        var _iterator13 = _createForOfIteratorHelper(_this5.addressMapping.entriesFromColumnsSpan(removedColumns)),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _step13$value = _slicedToArray(_step13.value, 2),
                address = _step13$value[0],
                vertex = _step13$value[1];

            var _iterator14 = _createForOfIteratorHelper(_this5.graph.adjacentNodes(vertex)),
                _step14;

            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var adjacentNode = _step14.value;

                _this5.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }

            if (vertex instanceof ArrayVertex) {
              if (vertex.isLeftCorner(address)) {
                _this5.shrinkArrayToCorner(vertex);

                _this5.arrayMapping.removeArray(vertex.getRange());
              } else {
                continue;
              }
            }

            _this5.removeVertex(vertex);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      });
      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, function () {
        _this5.addressMapping.removeColumns(removedColumns);
      });
      var affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, function () {
        var affectedRanges = _this5.truncateRanges(removedColumns, function (address) {
          return address.col;
        });

        return _this5.getArrayVerticesRelatedToRanges(affectedRanges);
      });
      this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, function () {
        return _this5.fixArraysAfterRemovingColumns(removedColumns.sheet, removedColumns.columnStart, removedColumns.numberOfColumns);
      });
      this.addStructuralNodesToChangeSet();
      return {
        affectedArrays: affectedArrays,
        contentChanges: this.getAndClearContentChanges()
      };
    }
  }, {
    key: "addRows",
    value: function addRows(addedRows) {
      var _this6 = this;

      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, function () {
        _this6.addressMapping.addRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
      });
      var affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, function () {
        var result = _this6.rangeMapping.moveAllRangesInSheetAfterRowByRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);

        _this6.fixRangesWhenAddingRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);

        return _this6.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);
      });
      this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, function () {
        _this6.fixArraysAfterAddingRow(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
      });

      var _iterator15 = _createForOfIteratorHelper(this.addressMapping.verticesFromRowsSpan(addedRows)),
          _step15;

      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var vertex = _step15.value;
          this.graph.markNodeAsSpecialRecentlyChanged(vertex);
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }

      this.addStructuralNodesToChangeSet();
      return {
        affectedArrays: affectedArrays
      };
    }
  }, {
    key: "addColumns",
    value: function addColumns(addedColumns) {
      var _this7 = this;

      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, function () {
        _this7.addressMapping.addColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
      });
      var affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, function () {
        var result = _this7.rangeMapping.moveAllRangesInSheetAfterColumnByColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);

        _this7.fixRangesWhenAddingColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);

        return _this7.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);
      });
      this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, function () {
        return _this7.fixArraysAfterAddingColumn(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
      });

      var _iterator16 = _createForOfIteratorHelper(this.addressMapping.verticesFromColumnsSpan(addedColumns)),
          _step16;

      try {
        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
          var vertex = _step16.value;
          this.graph.markNodeAsSpecialRecentlyChanged(vertex);
        }
      } catch (err) {
        _iterator16.e(err);
      } finally {
        _iterator16.f();
      }

      this.addStructuralNodesToChangeSet();
      return {
        affectedArrays: affectedArrays,
        contentChanges: this.getAndClearContentChanges()
      };
    }
  }, {
    key: "ensureNoArrayInRange",
    value: function ensureNoArrayInRange(range) {
      if (this.arrayMapping.isFormulaArrayInRange(range)) {
        throw Error('It is not possible to move / replace cells with array');
      }
    }
  }, {
    key: "isThereSpaceForArray",
    value: function isThereSpaceForArray(arrayVertex) {
      var range = arrayVertex.getRangeOrUndef();

      if (range === undefined) {
        return false;
      }

      var _iterator17 = _createForOfIteratorHelper(range.addresses(this)),
          _step17;

      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var address = _step17.value;
          var vertexUnderAddress = this.addressMapping.getCell(address);

          if (vertexUnderAddress !== undefined && !(vertexUnderAddress instanceof EmptyCellVertex) && vertexUnderAddress !== arrayVertex) {
            return false;
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }

      return true;
    }
  }, {
    key: "moveCells",
    value: function moveCells(sourceRange, toRight, toBottom, toSheet) {
      var _iterator18 = _createForOfIteratorHelper(sourceRange.addressesWithDirection(toRight, toBottom, this)),
          _step18;

      try {
        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
          var sourceAddress = _step18.value;
          var targetAddress = simpleCellAddress(toSheet, sourceAddress.col + toRight, sourceAddress.row + toBottom);
          var sourceVertex = this.addressMapping.getCell(sourceAddress);
          var targetVertex = this.addressMapping.getCell(targetAddress);
          this.addressMapping.removeCell(sourceAddress);

          if (sourceVertex !== undefined) {
            this.graph.markNodeAsSpecialRecentlyChanged(sourceVertex);
            this.addressMapping.setCell(targetAddress, sourceVertex);
            var emptyVertex = undefined;

            var _iterator20 = _createForOfIteratorHelper(this.graph.adjacentNodes(sourceVertex)),
                _step20;

            try {
              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                var adjacentNode = _step20.value;

                if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {
                  emptyVertex = emptyVertex !== null && emptyVertex !== void 0 ? emptyVertex : this.fetchCellOrCreateEmpty(sourceAddress);
                  this.graph.addEdge(emptyVertex, adjacentNode);
                  this.graph.removeEdge(sourceVertex, adjacentNode);
                }
              }
            } catch (err) {
              _iterator20.e(err);
            } finally {
              _iterator20.f();
            }

            if (emptyVertex) {
              this.graph.markNodeAsSpecialRecentlyChanged(emptyVertex);
              this.addressMapping.setCell(sourceAddress, emptyVertex);
            }
          }

          if (targetVertex !== undefined) {
            if (sourceVertex === undefined) {
              this.addressMapping.removeCell(targetAddress);
            }

            var _iterator21 = _createForOfIteratorHelper(this.graph.adjacentNodes(targetVertex)),
                _step21;

            try {
              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                var _adjacentNode = _step21.value;
                sourceVertex = sourceVertex !== null && sourceVertex !== void 0 ? sourceVertex : this.fetchCellOrCreateEmpty(targetAddress);
                this.graph.addEdge(sourceVertex, _adjacentNode);
                this.graph.markNodeAsSpecialRecentlyChanged(sourceVertex);
              }
            } catch (err) {
              _iterator21.e(err);
            } finally {
              _iterator21.f();
            }

            this.removeVertex(targetVertex);
          }
        }
      } catch (err) {
        _iterator18.e(err);
      } finally {
        _iterator18.f();
      }

      var _iterator19 = _createForOfIteratorHelper(this.rangeMapping.rangeVerticesContainedInRange(sourceRange)),
          _step19;

      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var rangeVertex = _step19.value;

          var _iterator22 = _createForOfIteratorHelper(this.graph.adjacentNodes(rangeVertex)),
              _step22;

          try {
            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
              var _adjacentNode2 = _step22.value;

              if (_adjacentNode2 instanceof RangeVertex && !sourceRange.containsRange(_adjacentNode2.range)) {
                this.graph.removeEdge(rangeVertex, _adjacentNode2);

                var _iterator23 = _createForOfIteratorHelper(rangeVertex.range.addresses(this)),
                    _step23;

                try {
                  for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                    var address = _step23.value;
                    var newEmptyVertex = this.fetchCellOrCreateEmpty(address);
                    this.graph.addEdge(newEmptyVertex, _adjacentNode2);
                    this.addressMapping.setCell(address, newEmptyVertex);
                    this.graph.markNodeAsSpecialRecentlyChanged(newEmptyVertex);
                  }
                } catch (err) {
                  _iterator23.e(err);
                } finally {
                  _iterator23.f();
                }
              }
            }
          } catch (err) {
            _iterator22.e(err);
          } finally {
            _iterator22.f();
          }
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }

      this.rangeMapping.moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet);
    }
  }, {
    key: "setArrayEmpty",
    value: function setArrayEmpty(arrayVertex) {
      var arrayRange = AbsoluteCellRange.spanFrom(arrayVertex.getAddress(this.lazilyTransformingAstService), arrayVertex.width, arrayVertex.height);
      var adjacentNodes = this.graph.adjacentNodes(arrayVertex);

      var _iterator24 = _createForOfIteratorHelper(arrayRange.addresses(this)),
          _step24;

      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var address = _step24.value;
          this.addressMapping.removeCell(address);
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }

      var _iterator25 = _createForOfIteratorHelper(adjacentNodes.values()),
          _step25;

      try {
        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
          var adjacentNode = _step25.value;
          var nodeDependencies = collectAddressesDependentToRange(this.functionRegistry, adjacentNode, arrayVertex.getRange(), this.lazilyTransformingAstService, this);

          var _iterator26 = _createForOfIteratorHelper(nodeDependencies),
              _step26;

          try {
            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
              var _address = _step26.value;
              var vertex = this.fetchCellOrCreateEmpty(_address);
              this.graph.addEdge(vertex, adjacentNode);
            }
          } catch (err) {
            _iterator26.e(err);
          } finally {
            _iterator26.f();
          }

          if (nodeDependencies.length > 0) {
            this.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);
          }
        }
      } catch (err) {
        _iterator25.e(err);
      } finally {
        _iterator25.f();
      }

      this.removeVertex(arrayVertex);
      this.arrayMapping.removeArray(arrayVertex.getRange());
    }
  }, {
    key: "addVertex",
    value: function addVertex(address, vertex) {
      this.graph.addNode(vertex);
      this.addressMapping.setCell(address, vertex);
    }
  }, {
    key: "addArrayVertex",
    value: function addArrayVertex(address, vertex) {
      this.graph.addNode(vertex);
      this.setAddressMappingForArrayVertex(vertex, address);
    }
  }, {
    key: "arrayFormulaNodes",
    value: /*#__PURE__*/regeneratorRuntime.mark(function arrayFormulaNodes() {
      var _iterator27, _step27, vertex;

      return regeneratorRuntime.wrap(function arrayFormulaNodes$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator27 = _createForOfIteratorHelper(this.graph.nodes);
              _context.prev = 1;

              _iterator27.s();

            case 3:
              if ((_step27 = _iterator27.n()).done) {
                _context.next = 10;
                break;
              }

              vertex = _step27.value;

              if (!(vertex instanceof ArrayVertex)) {
                _context.next = 8;
                break;
              }

              _context.next = 8;
              return vertex;

            case 8:
              _context.next = 3;
              break;

            case 10:
              _context.next = 15;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](1);

              _iterator27.e(_context.t0);

            case 15:
              _context.prev = 15;

              _iterator27.f();

              return _context.finish(15);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, arrayFormulaNodes, this, [[1, 12, 15, 18]]);
    })
  }, {
    key: "entriesFromRowsSpan",
    value: /*#__PURE__*/regeneratorRuntime.mark(function entriesFromRowsSpan(rowsSpan) {
      return regeneratorRuntime.wrap(function entriesFromRowsSpan$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(this.addressMapping.entriesFromRowsSpan(rowsSpan), "t0", 1);

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, entriesFromRowsSpan, this);
    })
  }, {
    key: "entriesFromColumnsSpan",
    value: /*#__PURE__*/regeneratorRuntime.mark(function entriesFromColumnsSpan(columnsSpan) {
      return regeneratorRuntime.wrap(function entriesFromColumnsSpan$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.delegateYield(this.addressMapping.entriesFromColumnsSpan(columnsSpan), "t0", 1);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, entriesFromColumnsSpan, this);
    })
  }, {
    key: "existsVertex",
    value: function existsVertex(address) {
      return this.addressMapping.has(address);
    }
  }, {
    key: "fetchCell",
    value: function fetchCell(address) {
      return this.addressMapping.fetchCell(address);
    }
  }, {
    key: "getCell",
    value: function getCell(address) {
      return this.addressMapping.getCell(address);
    }
  }, {
    key: "getCellValue",
    value: function getCellValue(address) {
      return this.addressMapping.getCellValue(address);
    }
  }, {
    key: "getRawValue",
    value: function getRawValue(address) {
      return this.addressMapping.getRawValue(address);
    }
  }, {
    key: "getScalarValue",
    value: function getScalarValue(address) {
      var value = this.addressMapping.getCellValue(address);

      if (value instanceof SimpleRangeValue) {
        return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);
      }

      return value;
    }
  }, {
    key: "existsEdge",
    value: function existsEdge(fromNode, toNode) {
      return this.graph.existsEdge(fromNode, toNode);
    }
  }, {
    key: "getSheetId",
    value: function getSheetId(sheetName) {
      return this.sheetMapping.fetch(sheetName);
    }
  }, {
    key: "getSheetHeight",
    value: function getSheetHeight(sheet) {
      return this.addressMapping.getHeight(sheet);
    }
  }, {
    key: "getSheetWidth",
    value: function getSheetWidth(sheet) {
      return this.addressMapping.getWidth(sheet);
    }
  }, {
    key: "getArray",
    value: function getArray(range) {
      return this.arrayMapping.getArray(range);
    }
  }, {
    key: "setArray",
    value: function setArray(range, vertex) {
      this.arrayMapping.setArray(range, vertex);
    }
  }, {
    key: "getRange",
    value: function getRange(start, end) {
      return this.rangeMapping.getRange(start, end);
    }
  }, {
    key: "topSortWithScc",
    value: function topSortWithScc() {
      return this.graph.topSortWithScc();
    }
  }, {
    key: "markAsVolatile",
    value: function markAsVolatile(vertex) {
      this.graph.markNodeAsSpecial(vertex);
    }
  }, {
    key: "markAsDependentOnStructureChange",
    value: function markAsDependentOnStructureChange(vertex) {
      this.graph.markNodeAsChangingWithStructure(vertex);
    }
  }, {
    key: "forceApplyPostponedTransformations",
    value: function forceApplyPostponedTransformations() {
      var _iterator28 = _createForOfIteratorHelper(this.graph.nodes.values()),
          _step28;

      try {
        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
          var vertex = _step28.value;

          if (vertex instanceof FormulaCellVertex) {
            vertex.ensureRecentData(this.lazilyTransformingAstService);
          }
        }
      } catch (err) {
        _iterator28.e(err);
      } finally {
        _iterator28.f();
      }
    }
  }, {
    key: "volatileVertices",
    value: function volatileVertices() {
      return this.graph.specialNodes;
    }
  }, {
    key: "getArrayVerticesRelatedToRanges",
    value: function getArrayVerticesRelatedToRanges(ranges) {
      var _this8 = this;

      var arrayVertices = ranges.map(function (range) {
        if (_this8.graph.hasNode(range)) {
          return Array.from(_this8.graph.adjacentNodes(range)).filter(function (node) {
            return node instanceof ArrayVertex;
          });
        } else {
          return [];
        }
      });
      return _construct(Set, _toConsumableArray(arrayVertices));
    }
  }, {
    key: "rawValuesFromRange",
    value: /*#__PURE__*/regeneratorRuntime.mark(function rawValuesFromRange(range) {
      var _iterator29, _step29, address, value;

      return regeneratorRuntime.wrap(function rawValuesFromRange$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _iterator29 = _createForOfIteratorHelper(range.addresses(this));
              _context4.prev = 1;

              _iterator29.s();

            case 3:
              if ((_step29 = _iterator29.n()).done) {
                _context4.next = 11;
                break;
              }

              address = _step29.value;
              value = this.getScalarValue(address);

              if (!(value !== EmptyValue)) {
                _context4.next = 9;
                break;
              }

              _context4.next = 9;
              return [getRawValue(value), address];

            case 9:
              _context4.next = 3;
              break;

            case 11:
              _context4.next = 16;
              break;

            case 13:
              _context4.prev = 13;
              _context4.t0 = _context4["catch"](1);

              _iterator29.e(_context4.t0);

            case 16:
              _context4.prev = 16;

              _iterator29.f();

              return _context4.finish(16);

            case 19:
            case "end":
              return _context4.stop();
          }
        }
      }, rawValuesFromRange, this, [[1, 13, 16, 19]]);
    })
  }, {
    key: "entriesFromRange",
    value: /*#__PURE__*/regeneratorRuntime.mark(function entriesFromRange(range) {
      var _iterator30, _step30, address;

      return regeneratorRuntime.wrap(function entriesFromRange$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _iterator30 = _createForOfIteratorHelper(range.addresses(this));
              _context5.prev = 1;

              _iterator30.s();

            case 3:
              if ((_step30 = _iterator30.n()).done) {
                _context5.next = 9;
                break;
              }

              address = _step30.value;
              _context5.next = 7;
              return [address, this.getCell(address)];

            case 7:
              _context5.next = 3;
              break;

            case 9:
              _context5.next = 14;
              break;

            case 11:
              _context5.prev = 11;
              _context5.t0 = _context5["catch"](1);

              _iterator30.e(_context5.t0);

            case 14:
              _context5.prev = 14;

              _iterator30.f();

              return _context5.finish(14);

            case 17:
            case "end":
              return _context5.stop();
          }
        }
      }, entriesFromRange, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "exchangeGraphNode",
    value: function exchangeGraphNode(oldNode, newNode) {
      var _this9 = this;

      this.graph.addNode(newNode);
      var adjNodesStored = this.graph.adjacentNodes(oldNode);
      this.removeVertex(oldNode);
      adjNodesStored.forEach(function (adjacentNode) {
        if (_this9.graph.hasNode(adjacentNode)) {
          _this9.graph.addEdge(newNode, adjacentNode);
        }
      });
    }
  }, {
    key: "exchangeOrAddGraphNode",
    value: function exchangeOrAddGraphNode(oldNode, newNode) {
      if (oldNode) {
        this.exchangeGraphNode(oldNode, newNode);
      } else {
        this.graph.addNode(newNode);
      }
    }
  }, {
    key: "computeListOfValuesInRange",
    value: function computeListOfValuesInRange(range) {
      var values = [];

      var _iterator31 = _createForOfIteratorHelper(range.addresses(this)),
          _step31;

      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var cellFromRange = _step31.value;
          var value = this.getScalarValue(cellFromRange);
          values.push(value);
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }

      return values;
    }
  }, {
    key: "shrinkArrayToCorner",
    value: function shrinkArrayToCorner(array) {
      this.cleanAddressMappingUnderArray(array);

      var _iterator32 = _createForOfIteratorHelper(this.adjacentArrayVertices(array)),
          _step32;

      try {
        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
          var adjacentVertex = _step32.value;
          var relevantDependencies = void 0;

          if (adjacentVertex instanceof FormulaVertex) {
            relevantDependencies = this.formulaDirectDependenciesToArray(adjacentVertex, array);
          } else {
            relevantDependencies = this.rangeDirectDependenciesToArray(adjacentVertex, array);
          }

          var dependentToCorner = false;

          var _iterator33 = _createForOfIteratorHelper(relevantDependencies),
              _step33;

          try {
            for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
              var _step33$value = _slicedToArray(_step33.value, 2),
                  address = _step33$value[0],
                  vertex = _step33$value[1];

              if (array.isLeftCorner(address)) {
                dependentToCorner = true;
              }

              this.graph.addEdge(vertex, adjacentVertex);
              this.graph.markNodeAsSpecialRecentlyChanged(vertex);
            }
          } catch (err) {
            _iterator33.e(err);
          } finally {
            _iterator33.f();
          }

          if (!dependentToCorner) {
            this.graph.removeEdge(array, adjacentVertex);
          }
        }
      } catch (err) {
        _iterator32.e(err);
      } finally {
        _iterator32.f();
      }

      this.graph.markNodeAsSpecialRecentlyChanged(array);
    }
  }, {
    key: "isArrayInternalCell",
    value: function isArrayInternalCell(address) {
      var vertex = this.getCell(address);
      return vertex instanceof ArrayVertex && !vertex.isLeftCorner(address);
    }
  }, {
    key: "getAndClearContentChanges",
    value: function getAndClearContentChanges() {
      var changes = this.changes;
      this.changes = ContentChanges.empty();
      return changes;
    }
  }, {
    key: "getAdjacentNodesAddresses",
    value: function getAdjacentNodesAddresses(inputVertex) {
      var _this10 = this;

      var deps = this.graph.adjacentNodes(inputVertex);
      var ret = [];
      deps.forEach(function (vertex) {
        var castVertex = vertex;

        if (castVertex instanceof RangeVertex) {
          ret.push(simpleCellRange(castVertex.start, castVertex.end));
        } else {
          ret.push(castVertex.getAddress(_this10.lazilyTransformingAstService));
        }
      });
      return ret;
    }
  }, {
    key: "correctInfiniteRangesDependenciesByRangeVertex",
    value: function correctInfiniteRangesDependenciesByRangeVertex(vertex) {
      var _iterator34 = _createForOfIteratorHelper(this.graph.infiniteRanges),
          _step34;

      try {
        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
          var range = _step34.value;
          var infiniteRangeVertex = range;
          var intersection = vertex.range.intersectionWith(infiniteRangeVertex.range);

          if (intersection === undefined) {
            continue;
          }

          var _iterator35 = _createForOfIteratorHelper(intersection.addresses(this)),
              _step35;

          try {
            for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
              var address = _step35.value;
              this.graph.addEdge(this.fetchCellOrCreateEmpty(address), range);
            }
          } catch (err) {
            _iterator35.e(err);
          } finally {
            _iterator35.f();
          }
        }
      } catch (err) {
        _iterator34.e(err);
      } finally {
        _iterator34.f();
      }
    }
  }, {
    key: "cleanAddressMappingUnderArray",
    value: function cleanAddressMappingUnderArray(vertex) {
      var arrayRange = vertex.getRange();

      var _iterator36 = _createForOfIteratorHelper(arrayRange.addresses(this)),
          _step36;

      try {
        for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
          var address = _step36.value;
          var oldValue = vertex.getArrayCellValue(address);

          if (this.getCell(address) === vertex) {
            if (vertex.isLeftCorner(address)) {
              this.changes.addChange(new CellError(ErrorType.REF), address, oldValue);
            } else {
              this.addressMapping.removeCell(address);
              this.changes.addChange(EmptyValue, address, oldValue);
            }
          } else {
            this.changes.addChange(EmptyValue, address, oldValue);
          }
        }
      } catch (err) {
        _iterator36.e(err);
      } finally {
        _iterator36.f();
      }
    }
  }, {
    key: "formulaDirectDependenciesToArray",
    value: /*#__PURE__*/regeneratorRuntime.mark(function formulaDirectDependenciesToArray(vertex, array) {
      var _a, _ref5, _ref6, formulaDependencies, _iterator37, _step37, dependency, _vertex;

      return regeneratorRuntime.wrap(function formulaDirectDependenciesToArray$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _ref5 = (_a = this.formulaDependencyQuery(vertex)) !== null && _a !== void 0 ? _a : [], _ref6 = _slicedToArray(_ref5, 2), formulaDependencies = _ref6[1];

              if (!(formulaDependencies === undefined)) {
                _context6.next = 3;
                break;
              }

              return _context6.abrupt("return");

            case 3:
              _iterator37 = _createForOfIteratorHelper(formulaDependencies);
              _context6.prev = 4;

              _iterator37.s();

            case 6:
              if ((_step37 = _iterator37.n()).done) {
                _context6.next = 16;
                break;
              }

              dependency = _step37.value;

              if (!(dependency instanceof NamedExpressionDependency || dependency instanceof AbsoluteCellRange)) {
                _context6.next = 10;
                break;
              }

              return _context6.abrupt("continue", 14);

            case 10:
              if (!array.getRange().addressInRange(dependency)) {
                _context6.next = 14;
                break;
              }

              _vertex = this.fetchCellOrCreateEmpty(dependency);
              _context6.next = 14;
              return [dependency, _vertex];

            case 14:
              _context6.next = 6;
              break;

            case 16:
              _context6.next = 21;
              break;

            case 18:
              _context6.prev = 18;
              _context6.t0 = _context6["catch"](4);

              _iterator37.e(_context6.t0);

            case 21:
              _context6.prev = 21;

              _iterator37.f();

              return _context6.finish(21);

            case 24:
            case "end":
              return _context6.stop();
          }
        }
      }, formulaDirectDependenciesToArray, this, [[4, 18, 21, 24]]);
    })
  }, {
    key: "rangeDirectDependenciesToArray",
    value: /*#__PURE__*/regeneratorRuntime.mark(function rangeDirectDependenciesToArray(vertex, array) {
      var _this$rangeMapping$fi2, range, _iterator38, _step38, address, cell;

      return regeneratorRuntime.wrap(function rangeDirectDependenciesToArray$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _this$rangeMapping$fi2 = this.rangeMapping.findSmallerRange(vertex.range), range = _this$rangeMapping$fi2.restRange;
              _iterator38 = _createForOfIteratorHelper(range.addresses(this));
              _context7.prev = 2;

              _iterator38.s();

            case 4:
              if ((_step38 = _iterator38.n()).done) {
                _context7.next = 12;
                break;
              }

              address = _step38.value;

              if (!array.getRange().addressInRange(address)) {
                _context7.next = 10;
                break;
              }

              cell = this.fetchCellOrCreateEmpty(address);
              _context7.next = 10;
              return [address, cell];

            case 10:
              _context7.next = 4;
              break;

            case 12:
              _context7.next = 17;
              break;

            case 14:
              _context7.prev = 14;
              _context7.t0 = _context7["catch"](2);

              _iterator38.e(_context7.t0);

            case 17:
              _context7.prev = 17;

              _iterator38.f();

              return _context7.finish(17);

            case 20:
            case "end":
              return _context7.stop();
          }
        }
      }, rangeDirectDependenciesToArray, this, [[2, 14, 17, 20]]);
    })
  }, {
    key: "adjacentArrayVertices",
    value: /*#__PURE__*/regeneratorRuntime.mark(function adjacentArrayVertices(vertex) {
      var adjacentNodes, _iterator39, _step39, item;

      return regeneratorRuntime.wrap(function adjacentArrayVertices$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              adjacentNodes = this.graph.adjacentNodes(vertex);
              _iterator39 = _createForOfIteratorHelper(adjacentNodes);
              _context8.prev = 2;

              _iterator39.s();

            case 4:
              if ((_step39 = _iterator39.n()).done) {
                _context8.next = 11;
                break;
              }

              item = _step39.value;

              if (!(item instanceof FormulaVertex || item instanceof RangeVertex)) {
                _context8.next = 9;
                break;
              }

              _context8.next = 9;
              return item;

            case 9:
              _context8.next = 4;
              break;

            case 11:
              _context8.next = 16;
              break;

            case 13:
              _context8.prev = 13;
              _context8.t0 = _context8["catch"](2);

              _iterator39.e(_context8.t0);

            case 16:
              _context8.prev = 16;

              _iterator39.f();

              return _context8.finish(16);

            case 19:
            case "end":
              return _context8.stop();
          }
        }
      }, adjacentArrayVertices, this, [[2, 13, 16, 19]]);
    })
  }, {
    key: "addStructuralNodesToChangeSet",
    value: function addStructuralNodesToChangeSet() {
      var _iterator40 = _createForOfIteratorHelper(this.graph.specialNodesStructuralChanges),
          _step40;

      try {
        for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
          var vertex = _step40.value;
          this.graph.markNodeAsSpecialRecentlyChanged(vertex);
        }
      } catch (err) {
        _iterator40.e(err);
      } finally {
        _iterator40.f();
      }
    }
  }, {
    key: "fixRangesWhenAddingRows",
    value: function fixRangesWhenAddingRows(sheet, row, numberOfRows) {
      var originalValues = Array.from(this.rangeMapping.rangesInSheet(sheet));

      for (var _i2 = 0, _originalValues = originalValues; _i2 < _originalValues.length; _i2++) {
        var rangeVertex = _originalValues[_i2];

        if (rangeVertex.range.includesRow(row + numberOfRows)) {
          if (rangeVertex.bruteForce) {
            var addedSubrangeInThatRange = rangeVertex.range.rangeWithSameWidth(row, numberOfRows);

            var _iterator41 = _createForOfIteratorHelper(addedSubrangeInThatRange.addresses(this)),
                _step41;

            try {
              for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                var address = _step41.value;
                this.graph.addEdge(this.fetchCellOrCreateEmpty(address), rangeVertex);
              }
            } catch (err) {
              _iterator41.e(err);
            } finally {
              _iterator41.f();
            }
          } else {
            var currentRangeVertex = rangeVertex;
            var find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);

            if (find.smallerRangeVertex !== undefined) {
              continue;
            }

            while (find.smallerRangeVertex === undefined) {
              var newRangeVertex = new RangeVertex(AbsoluteCellRange.spanFrom(currentRangeVertex.range.start, currentRangeVertex.range.width(), currentRangeVertex.range.height() - 1));
              this.rangeMapping.setRange(newRangeVertex);
              this.graph.addNode(newRangeVertex);
              var restRange = new AbsoluteCellRange(simpleCellAddress(currentRangeVertex.range.start.sheet, currentRangeVertex.range.start.col, currentRangeVertex.range.end.row), currentRangeVertex.range.end);
              this.addAllFromRange(restRange, currentRangeVertex);
              this.graph.addEdge(newRangeVertex, currentRangeVertex);
              currentRangeVertex = newRangeVertex;
              find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);
            }

            this.graph.addEdge(find.smallerRangeVertex, currentRangeVertex);
            this.addAllFromRange(find.restRange, currentRangeVertex);
            this.graph.removeEdge(find.smallerRangeVertex, rangeVertex);
          }
        }
      }
    }
  }, {
    key: "addAllFromRange",
    value: function addAllFromRange(range, vertex) {
      var _iterator42 = _createForOfIteratorHelper(range.addresses(this)),
          _step42;

      try {
        for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
          var address = _step42.value;
          this.graph.addEdge(this.fetchCellOrCreateEmpty(address), vertex);
        }
      } catch (err) {
        _iterator42.e(err);
      } finally {
        _iterator42.f();
      }
    }
  }, {
    key: "fixRangesWhenAddingColumns",
    value: function fixRangesWhenAddingColumns(sheet, column, numberOfColumns) {
      var _iterator43 = _createForOfIteratorHelper(this.rangeMapping.rangesInSheet(sheet)),
          _step43;

      try {
        for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
          var rangeVertex = _step43.value;

          if (rangeVertex.range.includesColumn(column + numberOfColumns)) {
            var subrange = void 0;

            if (rangeVertex.bruteForce) {
              subrange = rangeVertex.range.rangeWithSameHeight(column, numberOfColumns);
            } else {
              subrange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheet, column, rangeVertex.range.end.row), numberOfColumns, 1);
            }

            var _iterator44 = _createForOfIteratorHelper(subrange.addresses(this)),
                _step44;

            try {
              for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                var address = _step44.value;
                this.graph.addEdge(this.fetchCellOrCreateEmpty(address), rangeVertex);
              }
            } catch (err) {
              _iterator44.e(err);
            } finally {
              _iterator44.f();
            }
          }
        }
      } catch (err) {
        _iterator43.e(err);
      } finally {
        _iterator43.f();
      }
    }
  }, {
    key: "exchangeOrAddFormulaVertex",
    value: function exchangeOrAddFormulaVertex(vertex) {
      var address = vertex.getAddress(this.lazilyTransformingAstService);
      var range = AbsoluteCellRange.spanFrom(address, vertex.width, vertex.height);
      var oldNode = this.shrinkPossibleArrayAndGetCell(address);

      if (vertex instanceof ArrayVertex) {
        this.setArray(range, vertex);
      }

      this.exchangeOrAddGraphNode(oldNode, vertex);
      this.addressMapping.setCell(address, vertex);

      if (vertex instanceof ArrayVertex) {
        if (!this.isThereSpaceForArray(vertex)) {
          return;
        }

        var _iterator45 = _createForOfIteratorHelper(range.addresses(this)),
            _step45;

        try {
          for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
            var cellAddress = _step45.value;

            if (vertex.isLeftCorner(cellAddress)) {
              continue;
            }

            var old = this.getCell(cellAddress);
            this.exchangeOrAddGraphNode(old, vertex);
          }
        } catch (err) {
          _iterator45.e(err);
        } finally {
          _iterator45.f();
        }
      }

      var _iterator46 = _createForOfIteratorHelper(range.addresses(this)),
          _step46;

      try {
        for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
          var _cellAddress = _step46.value;
          this.addressMapping.setCell(_cellAddress, vertex);
        }
      } catch (err) {
        _iterator46.e(err);
      } finally {
        _iterator46.f();
      }
    }
  }, {
    key: "setAddressMappingForArrayVertex",
    value: function setAddressMappingForArrayVertex(vertex, formulaAddress) {
      this.addressMapping.setCell(formulaAddress, vertex);

      if (!(vertex instanceof ArrayVertex)) {
        return;
      }

      var range = AbsoluteCellRange.spanFromOrUndef(formulaAddress, vertex.width, vertex.height);

      if (range === undefined) {
        return;
      }

      this.setArray(range, vertex);

      if (!this.isThereSpaceForArray(vertex)) {
        return;
      }

      var _iterator47 = _createForOfIteratorHelper(range.addresses(this)),
          _step47;

      try {
        for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
          var address = _step47.value;
          this.addressMapping.setCell(address, vertex);
        }
      } catch (err) {
        _iterator47.e(err);
      } finally {
        _iterator47.f();
      }
    }
  }, {
    key: "truncateRanges",
    value: function truncateRanges(span, coordinate) {
      var _this$rangeMapping$tr = this.rangeMapping.truncateRanges(span, coordinate),
          verticesToRemove = _this$rangeMapping$tr.verticesToRemove,
          verticesToMerge = _this$rangeMapping$tr.verticesToMerge,
          verticesWithChangedSize = _this$rangeMapping$tr.verticesWithChangedSize;

      var _iterator48 = _createForOfIteratorHelper(verticesToMerge),
          _step48;

      try {
        for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
          var _step48$value = _slicedToArray(_step48.value, 2),
              existingVertex = _step48$value[0],
              mergedVertex = _step48$value[1];

          this.mergeRangeVertices(existingVertex, mergedVertex);
        }
      } catch (err) {
        _iterator48.e(err);
      } finally {
        _iterator48.f();
      }

      var _iterator49 = _createForOfIteratorHelper(verticesToRemove),
          _step49;

      try {
        for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
          var rangeVertex = _step49.value;
          this.removeVertexAndCleanupDependencies(rangeVertex);
        }
      } catch (err) {
        _iterator49.e(err);
      } finally {
        _iterator49.f();
      }

      return verticesWithChangedSize;
    }
  }, {
    key: "fixArraysAfterAddingRow",
    value: function fixArraysAfterAddingRow(sheet, rowStart, numberOfRows) {
      this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, numberOfRows);

      if (rowStart <= 0) {
        return;
      }

      var _iterator50 = _createForOfIteratorHelper(this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))),
          _step50;

      try {
        for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
          var _step50$value = _slicedToArray(_step50.value, 2),
              array = _step50$value[1];

          var arrayRange = array.getRange();

          for (var col = arrayRange.start.col; col <= arrayRange.end.col; ++col) {
            for (var row = rowStart; row <= arrayRange.end.row; ++row) {
              var destination = simpleCellAddress(sheet, col, row);
              var source = simpleCellAddress(sheet, col, row + numberOfRows);
              var value = array.getArrayCellValue(destination);
              this.addressMapping.moveCell(source, destination);
              this.changes.addChange(EmptyValue, source, value);
            }
          }
        }
      } catch (err) {
        _iterator50.e(err);
      } finally {
        _iterator50.f();
      }
    }
  }, {
    key: "fixArraysAfterRemovingRows",
    value: function fixArraysAfterRemovingRows(sheet, rowStart, numberOfRows) {
      this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, -numberOfRows);

      if (rowStart <= 0) {
        return;
      }

      var _iterator51 = _createForOfIteratorHelper(this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))),
          _step51;

      try {
        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
          var _step51$value = _slicedToArray(_step51.value, 2),
              array = _step51$value[1];

          if (this.isThereSpaceForArray(array)) {
            var _iterator52 = _createForOfIteratorHelper(array.getRange().addresses(this)),
                _step52;

            try {
              for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
                var address = _step52.value;
                this.addressMapping.setCell(address, array);
              }
            } catch (err) {
              _iterator52.e(err);
            } finally {
              _iterator52.f();
            }
          } else {
            this.setNoSpaceIfArray(array);
          }
        }
      } catch (err) {
        _iterator51.e(err);
      } finally {
        _iterator51.f();
      }
    }
  }, {
    key: "fixArraysAfterAddingColumn",
    value: function fixArraysAfterAddingColumn(sheet, columnStart, numberOfColumns) {
      this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, numberOfColumns);

      if (columnStart <= 0) {
        return;
      }

      var _iterator53 = _createForOfIteratorHelper(this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))),
          _step53;

      try {
        for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
          var _step53$value = _slicedToArray(_step53.value, 2),
              array = _step53$value[1];

          var arrayRange = array.getRange();

          for (var row = arrayRange.start.row; row <= arrayRange.end.row; ++row) {
            for (var col = columnStart; col <= arrayRange.end.col; ++col) {
              var destination = simpleCellAddress(sheet, col, row);
              var source = simpleCellAddress(sheet, col + numberOfColumns, row);
              var value = array.getArrayCellValue(destination);
              this.addressMapping.moveCell(source, destination);
              this.changes.addChange(EmptyValue, source, value);
            }
          }
        }
      } catch (err) {
        _iterator53.e(err);
      } finally {
        _iterator53.f();
      }
    }
  }, {
    key: "fixArraysAfterRemovingColumns",
    value: function fixArraysAfterRemovingColumns(sheet, columnStart, numberOfColumns) {
      this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, -numberOfColumns);

      if (columnStart <= 0) {
        return;
      }

      var _iterator54 = _createForOfIteratorHelper(this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))),
          _step54;

      try {
        for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
          var _step54$value = _slicedToArray(_step54.value, 2),
              array = _step54$value[1];

          if (this.isThereSpaceForArray(array)) {
            var _iterator55 = _createForOfIteratorHelper(array.getRange().addresses(this)),
                _step55;

            try {
              for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
                var address = _step55.value;
                this.addressMapping.setCell(address, array);
              }
            } catch (err) {
              _iterator55.e(err);
            } finally {
              _iterator55.f();
            }
          } else {
            this.setNoSpaceIfArray(array);
          }
        }
      } catch (err) {
        _iterator54.e(err);
      } finally {
        _iterator54.f();
      }
    }
  }, {
    key: "shrinkPossibleArrayAndGetCell",
    value: function shrinkPossibleArrayAndGetCell(address) {
      var vertex = this.getCell(address);

      if (!(vertex instanceof ArrayVertex)) {
        return vertex;
      }

      this.setNoSpaceIfArray(vertex);
      return this.getCell(address);
    }
  }, {
    key: "setNoSpaceIfArray",
    value: function setNoSpaceIfArray(vertex) {
      if (vertex instanceof ArrayVertex) {
        this.shrinkArrayToCorner(vertex);
        vertex.setNoSpace();
      }
    }
  }, {
    key: "removeVertex",
    value: function removeVertex(vertex) {
      this.removeVertexAndCleanupDependencies(vertex);

      if (vertex instanceof RangeVertex) {
        this.rangeMapping.removeRange(vertex);
      }
    }
  }, {
    key: "mergeRangeVertices",
    value: function mergeRangeVertices(existingVertex, newVertex) {
      var _this11 = this;

      var adjNodesStored = this.graph.adjacentNodes(newVertex);
      this.removeVertexAndCleanupDependencies(newVertex);
      this.graph.softRemoveEdge(existingVertex, newVertex);
      adjNodesStored.forEach(function (adjacentNode) {
        if (_this11.graph.hasNode(adjacentNode)) {
          _this11.graph.addEdge(existingVertex, adjacentNode);
        }
      });
    }
  }, {
    key: "removeVertexAndCleanupDependencies",
    value: function removeVertexAndCleanupDependencies(inputVertex) {
      var dependencies = new Set(this.graph.removeNode(inputVertex));

      while (dependencies.size > 0) {
        var vertex = dependencies.values().next().value;
        dependencies.delete(vertex);

        if (this.graph.hasNode(vertex) && this.graph.adjacentNodesCount(vertex) === 0) {
          if (vertex instanceof RangeVertex || vertex instanceof EmptyCellVertex) {
            this.graph.removeNode(vertex).forEach(function (candidate) {
              return dependencies.add(candidate);
            });
          }

          if (vertex instanceof RangeVertex) {
            this.rangeMapping.removeRange(vertex);
          } else if (vertex instanceof EmptyCellVertex) {
            this.addressMapping.removeCell(vertex.address);
          }
        }
      }
    }
  }], [{
    key: "buildEmpty",
    value: function buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats) {
      return new DependencyGraph(new AddressMapping(config.chooseAddressMappingPolicy), new RangeMapping(), new SheetMapping(config.translationPackage), new ArrayMapping(), stats, lazilyTransformingAstService, functionRegistry, namedExpressions);
    }
  }]);

  return DependencyGraph;
}();