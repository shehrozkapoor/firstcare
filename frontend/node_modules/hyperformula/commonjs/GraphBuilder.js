"use strict";

exports.__esModule = true;
exports.SimpleStrategy = exports.GraphBuilder = void 0;

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.map.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

var _absolutizeDependencies = require("./absolutizeDependencies");

var _ArraySize = require("./ArraySize");

var _Cell = require("./Cell");

var _CellContentParser = require("./CellContentParser");

var _DependencyGraph = require("./DependencyGraph");

var _InterpreterValue = require("./interpreter/InterpreterValue");

var _statistics = require("./statistics");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Service building the graph and mappings.
 */
var GraphBuilder = /*#__PURE__*/function () {
  /**
   * Configures the building service.
   */
  function GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {
    _classCallCheck(this, GraphBuilder);

    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.parser = parser;
    this.cellContentParser = cellContentParser;
    this.stats = stats;
    this.arraySizePredictor = arraySizePredictor;
    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);
  }
  /**
   * Builds graph.
   */


  _createClass(GraphBuilder, [{
    key: "buildGraph",
    value: function buildGraph(sheets, stats) {
      var _this = this;

      var dependencies = stats.measure(_statistics.StatType.COLLECT_DEPENDENCIES, function () {
        return _this.buildStrategy.run(sheets);
      });
      this.dependencyGraph.getAndClearContentChanges();
      stats.measure(_statistics.StatType.PROCESS_DEPENDENCIES, function () {
        return _this.processDependencies(dependencies);
      });
    }
  }, {
    key: "processDependencies",
    value: function processDependencies(dependencies) {
      var _this2 = this;

      dependencies.forEach(function (cellDependencies, endVertex) {
        _this2.dependencyGraph.processCellDependencies(cellDependencies, endVertex);
      });
    }
  }]);

  return GraphBuilder;
}();

exports.GraphBuilder = GraphBuilder;

var SimpleStrategy = /*#__PURE__*/function () {
  function SimpleStrategy(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {
    _classCallCheck(this, SimpleStrategy);

    this.dependencyGraph = dependencyGraph;
    this.columnIndex = columnIndex;
    this.parser = parser;
    this.stats = stats;
    this.cellContentParser = cellContentParser;
    this.arraySizePredictor = arraySizePredictor;
  }

  _createClass(SimpleStrategy, [{
    key: "run",
    value: function run(sheets) {
      var _this3 = this;

      var dependencies = new Map();

      for (var sheetName in sheets) {
        var sheetId = this.dependencyGraph.getSheetId(sheetName);
        var sheet = sheets[sheetName];

        for (var i = 0; i < sheet.length; ++i) {
          var row = sheet[i];

          var _loop = function _loop(j) {
            var cellContent = row[j];
            var address = (0, _Cell.simpleCellAddress)(sheetId, j, i);

            var parsedCellContent = _this3.cellContentParser.parse(cellContent);

            if (parsedCellContent instanceof _CellContentParser.CellContent.Formula) {
              var parseResult = _this3.stats.measure(_statistics.StatType.PARSER, function () {
                return _this3.parser.parse(parsedCellContent.formula, address);
              });

              if (parseResult.errors.length > 0) {
                _this3.shrinkArrayIfNeeded(address);

                var vertex = new _DependencyGraph.ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);

                _this3.dependencyGraph.addVertex(address, vertex);
              } else {
                _this3.shrinkArrayIfNeeded(address);

                var size = _this3.arraySizePredictor.checkArraySize(parseResult.ast, address);

                if (size.isScalar()) {
                  var _vertex = new _DependencyGraph.FormulaCellVertex(parseResult.ast, address, 0);

                  dependencies.set(_vertex, (0, _absolutizeDependencies.absolutizeDependencies)(parseResult.dependencies, address));

                  _this3.dependencyGraph.addVertex(address, _vertex);

                  if (parseResult.hasVolatileFunction) {
                    _this3.dependencyGraph.markAsVolatile(_vertex);
                  }

                  if (parseResult.hasStructuralChangeFunction) {
                    _this3.dependencyGraph.markAsDependentOnStructureChange(_vertex);
                  }
                } else {
                  var _vertex2 = new _DependencyGraph.ArrayVertex(parseResult.ast, address, new _ArraySize.ArraySize(size.width, size.height));

                  dependencies.set(_vertex2, (0, _absolutizeDependencies.absolutizeDependencies)(parseResult.dependencies, address));

                  _this3.dependencyGraph.addArrayVertex(address, _vertex2);
                }
              }
            } else if (parsedCellContent instanceof _CellContentParser.CellContent.Empty) {
              /* we don't care about empty cells here */
            } else {
              _this3.shrinkArrayIfNeeded(address);

              var _vertex3 = new _DependencyGraph.ValueCellVertex(parsedCellContent.value, cellContent);

              _this3.columnIndex.add((0, _InterpreterValue.getRawValue)(parsedCellContent.value), address);

              _this3.dependencyGraph.addVertex(address, _vertex3);
            }
          };

          for (var j = 0; j < row.length; ++j) {
            _loop(j);
          }
        }
      }

      return dependencies;
    }
  }, {
    key: "shrinkArrayIfNeeded",
    value: function shrinkArrayIfNeeded(address) {
      var vertex = this.dependencyGraph.getCell(address);

      if (vertex instanceof _DependencyGraph.ArrayVertex) {
        this.dependencyGraph.shrinkArrayToCorner(vertex);
      }
    }
  }]);

  return SimpleStrategy;
}();

exports.SimpleStrategy = SimpleStrategy;