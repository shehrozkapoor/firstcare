"use strict";

exports.__esModule = true;
exports.collectAddressesDependentToRange = void 0;

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.array.map.js");

var _parser = require("../parser");

var _FormulaCellVertex = require("./FormulaCellVertex");

var _RangeVertex = require("./RangeVertex");

/**
 * @license
 * Copyright (c) 2021 Handsoncode. All rights reserved.
 */
var collectAddressesDependentToRange = function collectAddressesDependentToRange(funcitonRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) {
  if (vertex instanceof _RangeVertex.RangeVertex) {
    var intersection = vertex.range.intersectionWith(range);

    if (intersection !== undefined) {
      return Array.from(intersection.addresses(dependencyGraph));
    } else {
      return [];
    }
  }

  var formula;
  var address;

  if (vertex instanceof _FormulaCellVertex.FormulaVertex) {
    formula = vertex.getFormula(lazilyTransformingAstService);
    address = vertex.getAddress(lazilyTransformingAstService);
  } else {
    return [];
  }

  return (0, _parser.collectDependencies)(formula, funcitonRegistry).filter(function (d) {
    return d instanceof _parser.AddressDependency;
  }).map(function (d) {
    return d.dependency.toSimpleCellAddress(address);
  }).filter(function (d) {
    return range.addressInRange(d);
  });
};

exports.collectAddressesDependentToRange = collectAddressesDependentToRange;