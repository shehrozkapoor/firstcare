"use strict";

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

exports.__esModule = true;
exports.RemoveRowsCommand = exports.RemoveColumnsCommand = exports.Operations = exports.AddRowsCommand = exports.AddColumnsCommand = void 0;
exports.normalizeAddedIndexes = normalizeAddedIndexes;
exports.normalizeRemovedIndexes = normalizeRemovedIndexes;

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.number.constructor.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.number.is-integer.js");

var _AbsoluteCellRange = require("./AbsoluteCellRange");

var _absolutizeDependencies = require("./absolutizeDependencies");

var _ArraySize = require("./ArraySize");

var _Cell = require("./Cell");

var _CellContentParser = require("./CellContentParser");

var _ClipboardOperations = require("./ClipboardOperations");

var _ContentChanges = require("./ContentChanges");

var _DependencyGraph = require("./DependencyGraph");

var _FormulaCellVertex = require("./DependencyGraph/FormulaCellVertex");

var _AddColumnsTransformer = require("./dependencyTransformers/AddColumnsTransformer");

var _AddRowsTransformer = require("./dependencyTransformers/AddRowsTransformer");

var _CleanOutOfScopeDependenciesTransformer = require("./dependencyTransformers/CleanOutOfScopeDependenciesTransformer");

var _MoveCellsTransformer = require("./dependencyTransformers/MoveCellsTransformer");

var _RemoveColumnsTransformer = require("./dependencyTransformers/RemoveColumnsTransformer");

var _RemoveRowsTransformer = require("./dependencyTransformers/RemoveRowsTransformer");

var _RemoveSheetTransformer = require("./dependencyTransformers/RemoveSheetTransformer");

var _errors = require("./errors");

var _InterpreterValue = require("./interpreter/InterpreterValue");

var _NamedExpressions = require("./NamedExpressions");

var _parser = require("./parser");

var _Sheet = require("./Sheet");

var _Span = require("./Span");

var _statistics = require("./statistics");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var RemoveRowsCommand = /*#__PURE__*/function () {
  function RemoveRowsCommand(sheet, indexes) {
    _classCallCheck(this, RemoveRowsCommand);

    this.sheet = sheet;
    this.indexes = indexes;
  }

  _createClass(RemoveRowsCommand, [{
    key: "normalizedIndexes",
    value: function normalizedIndexes() {
      return normalizeRemovedIndexes(this.indexes);
    }
  }, {
    key: "rowsSpans",
    value: function rowsSpans() {
      var _this = this;

      return this.normalizedIndexes().map(function (normalizedIndex) {
        return _Span.RowsSpan.fromNumberOfRows(_this.sheet, normalizedIndex[0], normalizedIndex[1]);
      });
    }
  }]);

  return RemoveRowsCommand;
}();

exports.RemoveRowsCommand = RemoveRowsCommand;

var AddRowsCommand = /*#__PURE__*/function () {
  function AddRowsCommand(sheet, indexes) {
    _classCallCheck(this, AddRowsCommand);

    this.sheet = sheet;
    this.indexes = indexes;
  }

  _createClass(AddRowsCommand, [{
    key: "normalizedIndexes",
    value: function normalizedIndexes() {
      return normalizeAddedIndexes(this.indexes);
    }
  }, {
    key: "rowsSpans",
    value: function rowsSpans() {
      var _this2 = this;

      return this.normalizedIndexes().map(function (normalizedIndex) {
        return _Span.RowsSpan.fromNumberOfRows(_this2.sheet, normalizedIndex[0], normalizedIndex[1]);
      });
    }
  }]);

  return AddRowsCommand;
}();

exports.AddRowsCommand = AddRowsCommand;

var AddColumnsCommand = /*#__PURE__*/function () {
  function AddColumnsCommand(sheet, indexes) {
    _classCallCheck(this, AddColumnsCommand);

    this.sheet = sheet;
    this.indexes = indexes;
  }

  _createClass(AddColumnsCommand, [{
    key: "normalizedIndexes",
    value: function normalizedIndexes() {
      return normalizeAddedIndexes(this.indexes);
    }
  }, {
    key: "columnsSpans",
    value: function columnsSpans() {
      var _this3 = this;

      return this.normalizedIndexes().map(function (normalizedIndex) {
        return _Span.ColumnsSpan.fromNumberOfColumns(_this3.sheet, normalizedIndex[0], normalizedIndex[1]);
      });
    }
  }]);

  return AddColumnsCommand;
}();

exports.AddColumnsCommand = AddColumnsCommand;

var RemoveColumnsCommand = /*#__PURE__*/function () {
  function RemoveColumnsCommand(sheet, indexes) {
    _classCallCheck(this, RemoveColumnsCommand);

    this.sheet = sheet;
    this.indexes = indexes;
  }

  _createClass(RemoveColumnsCommand, [{
    key: "normalizedIndexes",
    value: function normalizedIndexes() {
      return normalizeRemovedIndexes(this.indexes);
    }
  }, {
    key: "columnsSpans",
    value: function columnsSpans() {
      var _this4 = this;

      return this.normalizedIndexes().map(function (normalizedIndex) {
        return _Span.ColumnsSpan.fromNumberOfColumns(_this4.sheet, normalizedIndex[0], normalizedIndex[1]);
      });
    }
  }]);

  return RemoveColumnsCommand;
}();

exports.RemoveColumnsCommand = RemoveColumnsCommand;

var Operations = /*#__PURE__*/function () {
  function Operations(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {
    _classCallCheck(this, Operations);

    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.cellContentParser = cellContentParser;
    this.parser = parser;
    this.stats = stats;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.namedExpressions = namedExpressions;
    this.arraySizePredictor = arraySizePredictor;
    this.changes = _ContentChanges.ContentChanges.empty();
    this.allocateNamedExpressionAddressSpace();
    this.maxColumns = config.maxColumns;
    this.maxRows = config.maxRows;
  }

  _createClass(Operations, [{
    key: "sheetMapping",
    get: function get() {
      return this.dependencyGraph.sheetMapping;
    }
  }, {
    key: "addressMapping",
    get: function get() {
      return this.dependencyGraph.addressMapping;
    }
  }, {
    key: "removeRows",
    value: function removeRows(cmd) {
      var rowsRemovals = [];

      var _iterator = _createForOfIteratorHelper(cmd.rowsSpans()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var rowsToRemove = _step.value;
          var rowsRemoval = this.doRemoveRows(rowsToRemove);

          if (rowsRemoval) {
            rowsRemovals.push(rowsRemoval);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return rowsRemovals;
    }
  }, {
    key: "addRows",
    value: function addRows(cmd) {
      var _iterator2 = _createForOfIteratorHelper(cmd.rowsSpans()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var addedRows = _step2.value;
          this.doAddRows(addedRows);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "addColumns",
    value: function addColumns(cmd) {
      var _iterator3 = _createForOfIteratorHelper(cmd.columnsSpans()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var addedColumns = _step3.value;
          this.doAddColumns(addedColumns);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "removeColumns",
    value: function removeColumns(cmd) {
      var columnsRemovals = [];

      var _iterator4 = _createForOfIteratorHelper(cmd.columnsSpans()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var columnsToRemove = _step4.value;
          var columnsRemoval = this.doRemoveColumns(columnsToRemove);

          if (columnsRemoval) {
            columnsRemovals.push(columnsRemoval);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return columnsRemovals;
    }
  }, {
    key: "removeSheet",
    value: function removeSheet(sheetId) {
      var _this5 = this;

      this.dependencyGraph.removeSheet(sheetId);
      var version;
      this.stats.measure(_statistics.StatType.TRANSFORM_ASTS, function () {
        var transformation = new _RemoveSheetTransformer.RemoveSheetTransformer(sheetId);
        transformation.performEagerTransformations(_this5.dependencyGraph, _this5.parser);
        version = _this5.lazilyTransformingAstService.addTransformation(transformation);
      });
      this.sheetMapping.removeSheet(sheetId);
      this.columnSearch.removeSheet(sheetId);
      var scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(function (namedexpression) {
        return _this5.removeNamedExpression(namedexpression.normalizeExpressionName(), sheetId);
      });
      return {
        version: version,
        scopedNamedExpressions: scopedNamedExpressions
      };
    }
  }, {
    key: "removeSheetByName",
    value: function removeSheetByName(sheetName) {
      var sheetId = this.sheetMapping.fetch(sheetName);
      return this.removeSheet(sheetId);
    }
  }, {
    key: "clearSheet",
    value: function clearSheet(sheetId) {
      this.dependencyGraph.clearSheet(sheetId);
      this.columnSearch.removeSheet(sheetId);
    }
  }, {
    key: "addSheet",
    value: function addSheet(name) {
      var sheetId = this.sheetMapping.addSheet(name);
      var sheet = [];
      this.dependencyGraph.addressMapping.autoAddSheet(sheetId, sheet, (0, _Sheet.findBoundaries)(sheet));
      return this.sheetMapping.fetchDisplayName(sheetId);
    }
  }, {
    key: "renameSheet",
    value: function renameSheet(sheetId, newName) {
      return this.sheetMapping.renameSheet(sheetId, newName);
    }
  }, {
    key: "moveRows",
    value: function moveRows(sheet, startRow, numberOfRows, targetRow) {
      var rowsToAdd = _Span.RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);

      this.lazilyTransformingAstService.beginCombinedMode(sheet);
      this.doAddRows(rowsToAdd);

      if (targetRow < startRow) {
        startRow += numberOfRows;
      }

      var startAddress = (0, _Cell.simpleCellAddress)(sheet, 0, startRow);
      var targetAddress = (0, _Cell.simpleCellAddress)(sheet, 0, targetRow);
      this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);

      var rowsToRemove = _Span.RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);

      this.doRemoveRows(rowsToRemove);
      return this.lazilyTransformingAstService.commitCombinedMode();
    }
  }, {
    key: "moveColumns",
    value: function moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
      var columnsToAdd = _Span.ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);

      this.lazilyTransformingAstService.beginCombinedMode(sheet);
      this.doAddColumns(columnsToAdd);

      if (targetColumn < startColumn) {
        startColumn += numberOfColumns;
      }

      var startAddress = (0, _Cell.simpleCellAddress)(sheet, startColumn, 0);
      var targetAddress = (0, _Cell.simpleCellAddress)(sheet, targetColumn, 0);
      this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);

      var columnsToRemove = _Span.ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);

      this.doRemoveColumns(columnsToRemove);
      return this.lazilyTransformingAstService.commitCombinedMode();
    }
  }, {
    key: "moveCells",
    value: function moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
      var _this6 = this;

      this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);

      var sourceRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);

      var targetRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);

      var toRight = destinationLeftCorner.col - sourceLeftCorner.col;
      var toBottom = destinationLeftCorner.row - sourceLeftCorner.row;
      var toSheet = destinationLeftCorner.sheet;
      var currentDataAtTarget = this.getRangeClipboardCells(targetRange);
      var valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);
      this.columnSearch.removeValues(valuesToRemove);
      var valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);
      this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);
      var version;
      this.stats.measure(_statistics.StatType.TRANSFORM_ASTS, function () {
        var transformation = new _MoveCellsTransformer.MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);
        transformation.performEagerTransformations(_this6.dependencyGraph, _this6.parser);
        version = _this6.lazilyTransformingAstService.addTransformation(transformation);
      });
      this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);
      var addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);
      return {
        version: version,
        overwrittenCellsData: currentDataAtTarget,
        addedGlobalNamedExpressions: addedGlobalNamedExpressions
      };
    }
  }, {
    key: "setRowOrder",
    value: function setRowOrder(sheetId, rowMapping) {
      var _this7 = this;

      var buffer = [];
      var oldContent = [];

      var _iterator5 = _createForOfIteratorHelper(rowMapping),
          _step5;

      try {
        var _loop = function _loop() {
          var _step5$value = _slicedToArray(_step5.value, 2),
              source = _step5$value[0],
              target = _step5$value[1];

          if (source !== target) {
            var rowRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom({
              sheet: sheetId,
              col: 0,
              row: source
            }, Infinity, 1);

            var row = _this7.getRangeClipboardCells(rowRange);

            oldContent = oldContent.concat(row);
            buffer.push(row.map(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  _ref2$ = _ref2[0],
                  sheet = _ref2$.sheet,
                  col = _ref2$.col,
                  cell = _ref2[1];

              return [{
                sheet: sheet,
                col: col,
                row: target
              }, cell];
            }));
          }
        };

        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      buffer.forEach(function (row) {
        return _this7.restoreClipboardCells(sheetId, row.values());
      });
      return oldContent;
    }
  }, {
    key: "setColumnOrder",
    value: function setColumnOrder(sheetId, columnMapping) {
      var _this8 = this;

      var buffer = [];
      var oldContent = [];

      var _iterator6 = _createForOfIteratorHelper(columnMapping),
          _step6;

      try {
        var _loop2 = function _loop2() {
          var _step6$value = _slicedToArray(_step6.value, 2),
              source = _step6$value[0],
              target = _step6$value[1];

          if (source !== target) {
            var rowRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom({
              sheet: sheetId,
              col: source,
              row: 0
            }, 1, Infinity);

            var column = _this8.getRangeClipboardCells(rowRange);

            oldContent = oldContent.concat(column);
            buffer.push(column.map(function (_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2),
                  _ref4$ = _ref4[0],
                  sheet = _ref4$.sheet,
                  _col = _ref4$.col,
                  row = _ref4$.row,
                  cell = _ref4[1];

              return [{
                sheet: sheet,
                col: target,
                row: row
              }, cell];
            }));
          }
        };

        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      buffer.forEach(function (column) {
        return _this8.restoreClipboardCells(sheetId, column.values());
      });
      return oldContent;
    }
  }, {
    key: "addNamedExpression",
    value: function addNamedExpression(expressionName, expression, sheetId, options) {
      var namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);
      this.storeNamedExpressionInCell(namedExpression.address, expression);
      this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);
    }
  }, {
    key: "restoreNamedExpression",
    value: function restoreNamedExpression(namedExpression, content, sheetId) {
      var expressionName = namedExpression.displayName;
      this.restoreCell(namedExpression.address, content);
      var restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);
      this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);
    }
  }, {
    key: "changeNamedExpressionExpression",
    value: function changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {
      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);

      if (!namedExpression) {
        throw new _errors.NamedExpressionDoesNotExistError(expressionName);
      }

      var oldNamedExpression = namedExpression.copy();
      namedExpression.options = options;
      var content = this.getClipboardCell(namedExpression.address);
      this.storeNamedExpressionInCell(namedExpression.address, newExpression);
      return [oldNamedExpression, content];
    }
  }, {
    key: "removeNamedExpression",
    value: function removeNamedExpression(expressionName, sheetId) {
      var namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);

      if (!namedExpression) {
        throw new _errors.NamedExpressionDoesNotExistError(expressionName);
      }

      this.namedExpressions.remove(namedExpression.displayName, sheetId);
      var content = this.getClipboardCell(namedExpression.address);

      if (sheetId !== undefined) {
        var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);
        this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);
      } else {
        this.dependencyGraph.setCellEmpty(namedExpression.address);
      }

      return [namedExpression, content];
    }
  }, {
    key: "ensureItIsPossibleToMoveCells",
    value: function ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
      if ((0, _Cell.invalidSimpleCellAddress)(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || (0, _Cell.invalidSimpleCellAddress)(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {
        throw new _errors.InvalidArgumentsError('a valid range of cells to move.');
      }

      var sourceRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);

      var targetRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);

      if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
        throw new _errors.SheetSizeLimitExceededError();
      }

      if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
        throw new _errors.SourceLocationHasArrayError();
      }

      if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {
        throw new _errors.TargetLocationHasArrayError();
      }
    }
  }, {
    key: "restoreClipboardCells",
    value: function restoreClipboardCells(sourceSheetId, cells) {
      var addedNamedExpressions = [];

      var _iterator7 = _createForOfIteratorHelper(cells),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _step7$value = _slicedToArray(_step7.value, 2),
              address = _step7$value[0],
              clipboardCell = _step7$value[1];

          this.restoreCell(address, clipboardCell);

          if (clipboardCell.type === _ClipboardOperations.ClipboardCellType.FORMULA) {
            var _this$parser$fetchCac = this.parser.fetchCachedResult(clipboardCell.hash),
                dependencies = _this$parser$fetchCac.dependencies;

            addedNamedExpressions.push.apply(addedNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies)));
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      return addedNamedExpressions;
    }
  }, {
    key: "restoreCell",
    value: function restoreCell(address, clipboardCell) {
      switch (clipboardCell.type) {
        case _ClipboardOperations.ClipboardCellType.VALUE:
          {
            this.setValueToCell(clipboardCell, address);
            break;
          }

        case _ClipboardOperations.ClipboardCellType.FORMULA:
          {
            this.setFormulaToCellFromCache(clipboardCell.hash, address);
            break;
          }

        case _ClipboardOperations.ClipboardCellType.EMPTY:
          {
            this.setCellEmpty(address);
            break;
          }

        case _ClipboardOperations.ClipboardCellType.PARSING_ERROR:
          {
            this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);
            break;
          }
      }
    }
  }, {
    key: "getOldContent",
    value: function getOldContent(address) {
      var vertex = this.dependencyGraph.getCell(address);

      if (vertex === undefined || vertex instanceof _DependencyGraph.EmptyCellVertex) {
        return [address, {
          type: _ClipboardOperations.ClipboardCellType.EMPTY
        }];
      } else if (vertex instanceof _DependencyGraph.ValueCellVertex) {
        return [address, Object.assign({
          type: _ClipboardOperations.ClipboardCellType.VALUE
        }, vertex.getValues())];
      } else if (vertex instanceof _FormulaCellVertex.FormulaVertex) {
        return [vertex.getAddress(this.lazilyTransformingAstService), {
          type: _ClipboardOperations.ClipboardCellType.FORMULA,
          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))
        }];
      } else if (vertex instanceof _DependencyGraph.ParsingErrorVertex) {
        return [address, {
          type: _ClipboardOperations.ClipboardCellType.PARSING_ERROR,
          rawInput: vertex.rawInput,
          errors: vertex.errors
        }];
      }

      throw Error('Trying to copy unsupported type');
    }
  }, {
    key: "getClipboardCell",
    value: function getClipboardCell(address) {
      var vertex = this.dependencyGraph.getCell(address);

      if (vertex === undefined || vertex instanceof _DependencyGraph.EmptyCellVertex) {
        return {
          type: _ClipboardOperations.ClipboardCellType.EMPTY
        };
      } else if (vertex instanceof _DependencyGraph.ValueCellVertex) {
        return Object.assign({
          type: _ClipboardOperations.ClipboardCellType.VALUE
        }, vertex.getValues());
      } else if (vertex instanceof _DependencyGraph.ArrayVertex) {
        var val = vertex.getArrayCellValue(address);

        if (val === _InterpreterValue.EmptyValue) {
          return {
            type: _ClipboardOperations.ClipboardCellType.EMPTY
          };
        }

        return {
          type: _ClipboardOperations.ClipboardCellType.VALUE,
          parsedValue: val,
          rawValue: vertex.getArrayCellRawValue(address)
        };
      } else if (vertex instanceof _DependencyGraph.FormulaCellVertex) {
        return {
          type: _ClipboardOperations.ClipboardCellType.FORMULA,
          hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))
        };
      } else if (vertex instanceof _DependencyGraph.ParsingErrorVertex) {
        return {
          type: _ClipboardOperations.ClipboardCellType.PARSING_ERROR,
          rawInput: vertex.rawInput,
          errors: vertex.errors
        };
      }

      throw Error('Trying to copy unsupported type');
    }
  }, {
    key: "getSheetClipboardCells",
    value: function getSheetClipboardCells(sheet) {
      var sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
      var sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
      var arr = new Array(sheetHeight);

      for (var i = 0; i < sheetHeight; i++) {
        arr[i] = new Array(sheetWidth);

        for (var j = 0; j < sheetWidth; j++) {
          var address = (0, _Cell.simpleCellAddress)(sheet, j, i);
          arr[i][j] = this.getClipboardCell(address);
        }
      }

      return arr;
    }
  }, {
    key: "getRangeClipboardCells",
    value: function getRangeClipboardCells(range) {
      var result = [];

      var _iterator8 = _createForOfIteratorHelper(range.addresses(this.dependencyGraph)),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var address = _step8.value;
          result.push([address, this.getClipboardCell(address)]);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      return result;
    }
  }, {
    key: "setCellContent",
    value: function setCellContent(address, newCellContent) {
      var parsedCellContent = this.cellContentParser.parse(newCellContent);
      var oldContent = this.getOldContent(address);

      if (parsedCellContent instanceof _CellContentParser.CellContent.Formula) {
        var parserResult = this.parser.parse(parsedCellContent.formula, address);
        var ast = parserResult.ast,
            errors = parserResult.errors;

        if (errors.length > 0) {
          this.setParsingErrorToCell(parsedCellContent.formula, errors, address);
        } else {
          var size = this.arraySizePredictor.checkArraySize(ast, address);
          this.setFormulaToCell(address, size, parserResult);
        }
      } else if (parsedCellContent instanceof _CellContentParser.CellContent.Empty) {
        this.setCellEmpty(address);
      } else {
        this.setValueToCell({
          parsedValue: parsedCellContent.value,
          rawValue: newCellContent
        }, address);
      }

      return oldContent;
    }
  }, {
    key: "setSheetContent",
    value: function setSheetContent(sheetId, newSheetContent) {
      this.clearSheet(sheetId);

      for (var i = 0; i < newSheetContent.length; i++) {
        for (var j = 0; j < newSheetContent[i].length; j++) {
          var address = (0, _Cell.simpleCellAddress)(sheetId, j, i);
          this.setCellContent(address, newSheetContent[i][j]);
        }
      }
    }
  }, {
    key: "setParsingErrorToCell",
    value: function setParsingErrorToCell(rawInput, errors, address) {
      var oldValue = this.dependencyGraph.getCellValue(address);
      var vertex = new _DependencyGraph.ParsingErrorVertex(errors, rawInput);
      var arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);
      this.columnSearch.remove((0, _InterpreterValue.getRawValue)(oldValue), address);
      this.columnSearch.applyChanges(arrayChanges.getChanges());
      this.changes.addAll(arrayChanges);
      this.changes.addChange(vertex.getCellValue(), address);
    }
  }, {
    key: "setFormulaToCell",
    value: function setFormulaToCell(address, size, _ref5) {
      var ast = _ref5.ast,
          hasVolatileFunction = _ref5.hasVolatileFunction,
          hasStructuralChangeFunction = _ref5.hasStructuralChangeFunction,
          dependencies = _ref5.dependencies;
      var oldValue = this.dependencyGraph.getCellValue(address);
      var arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, (0, _absolutizeDependencies.absolutizeDependencies)(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);
      this.columnSearch.remove((0, _InterpreterValue.getRawValue)(oldValue), address);
      this.columnSearch.applyChanges(arrayChanges.getChanges());
      this.changes.addAll(arrayChanges);
    }
  }, {
    key: "setValueToCell",
    value: function setValueToCell(value, address) {
      var oldValue = this.dependencyGraph.getCellValue(address);
      var arrayChanges = this.dependencyGraph.setValueToCell(address, value);
      this.columnSearch.change((0, _InterpreterValue.getRawValue)(oldValue), (0, _InterpreterValue.getRawValue)(value.parsedValue), address);
      this.columnSearch.applyChanges(arrayChanges.getChanges().filter(function (change) {
        return !(0, _Cell.equalSimpleCellAddress)(change.address, address);
      }));
      this.changes.addAll(arrayChanges);
      this.changes.addChange(value.parsedValue, address);
    }
  }, {
    key: "setCellEmpty",
    value: function setCellEmpty(address) {
      if (this.dependencyGraph.isArrayInternalCell(address)) {
        return;
      }

      var oldValue = this.dependencyGraph.getCellValue(address);
      var arrayChanges = this.dependencyGraph.setCellEmpty(address);
      this.columnSearch.remove((0, _InterpreterValue.getRawValue)(oldValue), address);
      this.columnSearch.applyChanges(arrayChanges.getChanges());
      this.changes.addAll(arrayChanges);
      this.changes.addChange(_InterpreterValue.EmptyValue, address);
    }
  }, {
    key: "setFormulaToCellFromCache",
    value: function setFormulaToCellFromCache(formulaHash, address) {
      var _this$parser$fetchCac2 = this.parser.fetchCachedResult(formulaHash),
          ast = _this$parser$fetchCac2.ast,
          hasVolatileFunction = _this$parser$fetchCac2.hasVolatileFunction,
          hasStructuralChangeFunction = _this$parser$fetchCac2.hasStructuralChangeFunction,
          dependencies = _this$parser$fetchCac2.dependencies;

      var absoluteDependencies = (0, _absolutizeDependencies.absolutizeDependencies)(dependencies, address);

      var _CleanOutOfScopeDepen = new _CleanOutOfScopeDependenciesTransformer.CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address),
          _CleanOutOfScopeDepen2 = _slicedToArray(_CleanOutOfScopeDepen, 1),
          cleanedAst = _CleanOutOfScopeDepen2[0];

      this.parser.rememberNewAst(cleanedAst);
      var cleanedDependencies = (0, _absolutizeDependencies.filterDependenciesOutOfScope)(absoluteDependencies);
      var size = this.arraySizePredictor.checkArraySize(ast, address);
      this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);
    }
    /**
     * Returns true if row number is outside of given sheet.
     *
     * @param row - row number
     * @param sheet - sheet id number
     */

  }, {
    key: "rowEffectivelyNotInSheet",
    value: function rowEffectivelyNotInSheet(row, sheet) {
      var height = this.dependencyGraph.addressMapping.getHeight(sheet);
      return row >= height;
    }
  }, {
    key: "getAndClearContentChanges",
    value: function getAndClearContentChanges() {
      var changes = this.changes;
      this.changes = _ContentChanges.ContentChanges.empty();
      return changes;
    }
  }, {
    key: "forceApplyPostponedTransformations",
    value: function forceApplyPostponedTransformations() {
      this.dependencyGraph.forceApplyPostponedTransformations();
    }
    /**
     * Removes multiple rows from sheet. </br>
     * Does nothing if rows are outside of effective sheet size.
     *
     * @param sheet - sheet id from which rows will be removed
     * @param rowStart - number of the first row to be deleted
     * @param rowEnd - number of the last row to be deleted
     * */

  }, {
    key: "doRemoveRows",
    value: function doRemoveRows(rowsToRemove) {
      var _this9 = this;

      if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {
        return;
      }

      var removedCells = [];

      var _iterator9 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var _step9$value = _slicedToArray(_step9.value, 1),
              address = _step9$value[0];

          removedCells.push({
            address: address,
            cellType: this.getClipboardCell(address)
          });
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      var _this$dependencyGraph = this.dependencyGraph.removeRows(rowsToRemove),
          affectedArrays = _this$dependencyGraph.affectedArrays,
          contentChanges = _this$dependencyGraph.contentChanges;

      this.columnSearch.applyChanges(contentChanges.getChanges());
      var version;
      this.stats.measure(_statistics.StatType.TRANSFORM_ASTS, function () {
        var transformation = new _RemoveRowsTransformer.RemoveRowsTransformer(rowsToRemove);
        transformation.performEagerTransformations(_this9.dependencyGraph, _this9.parser);
        version = _this9.lazilyTransformingAstService.addTransformation(transformation);
      });
      this.rewriteAffectedArrays(affectedArrays);
      return {
        version: version,
        removedCells: removedCells,
        rowFrom: rowsToRemove.rowStart,
        rowCount: rowsToRemove.numberOfRows
      };
    }
    /**
     * Removes multiple columns from sheet. </br>
     * Does nothing if columns are outside of effective sheet size.
     *
     * @param sheet - sheet id from which columns will be removed
     * @param columnStart - number of the first column to be deleted
     * @param columnEnd - number of the last row to be deleted
     */

  }, {
    key: "doRemoveColumns",
    value: function doRemoveColumns(columnsToRemove) {
      var _this10 = this;

      if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {
        return;
      }

      var removedCells = [];

      var _iterator10 = _createForOfIteratorHelper(this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _step10$value = _slicedToArray(_step10.value, 1),
              address = _step10$value[0];

          removedCells.push({
            address: address,
            cellType: this.getClipboardCell(address)
          });
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      var _this$dependencyGraph2 = this.dependencyGraph.removeColumns(columnsToRemove),
          affectedArrays = _this$dependencyGraph2.affectedArrays,
          contentChanges = _this$dependencyGraph2.contentChanges;

      this.columnSearch.applyChanges(contentChanges.getChanges());
      this.columnSearch.removeColumns(columnsToRemove);
      var version;
      this.stats.measure(_statistics.StatType.TRANSFORM_ASTS, function () {
        var transformation = new _RemoveColumnsTransformer.RemoveColumnsTransformer(columnsToRemove);
        transformation.performEagerTransformations(_this10.dependencyGraph, _this10.parser);
        version = _this10.lazilyTransformingAstService.addTransformation(transformation);
      });
      this.rewriteAffectedArrays(affectedArrays);
      return {
        version: version,
        removedCells: removedCells,
        columnFrom: columnsToRemove.columnStart,
        columnCount: columnsToRemove.numberOfColumns
      };
    }
    /**
     * Add multiple rows to sheet. </br>
     * Does nothing if rows are outside of effective sheet size.
     *
     * @param sheet - sheet id in which rows will be added
     * @param row - row number above which the rows will be added
     * @param numberOfRowsToAdd - number of rows to add
     */

  }, {
    key: "doAddRows",
    value: function doAddRows(addedRows) {
      var _this11 = this;

      if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {
        return;
      }

      var _this$dependencyGraph3 = this.dependencyGraph.addRows(addedRows),
          affectedArrays = _this$dependencyGraph3.affectedArrays;

      this.stats.measure(_statistics.StatType.TRANSFORM_ASTS, function () {
        var transformation = new _AddRowsTransformer.AddRowsTransformer(addedRows);
        transformation.performEagerTransformations(_this11.dependencyGraph, _this11.parser);

        _this11.lazilyTransformingAstService.addTransformation(transformation);
      });
      this.rewriteAffectedArrays(affectedArrays);
    }
  }, {
    key: "rewriteAffectedArrays",
    value: function rewriteAffectedArrays(affectedArrays) {
      var _iterator11 = _createForOfIteratorHelper(affectedArrays.values()),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var arrayVertex = _step11.value;

          if (arrayVertex.array.size.isRef) {
            continue;
          }

          var ast = arrayVertex.getFormula(this.lazilyTransformingAstService);
          var address = arrayVertex.getAddress(this.lazilyTransformingAstService);
          var hash = this.parser.computeHashFromAst(ast);
          this.setFormulaToCellFromCache(hash, address);
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
    /**
     * Add multiple columns to sheet </br>
     * Does nothing if columns are outside of effective sheet size
     *
     * @param sheet - sheet id in which columns will be added
     * @param column - column number above which the columns will be added
     * @param numberOfColumns - number of columns to add
     */

  }, {
    key: "doAddColumns",
    value: function doAddColumns(addedColumns) {
      var _this12 = this;

      if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {
        return;
      }

      var _this$dependencyGraph4 = this.dependencyGraph.addColumns(addedColumns),
          affectedArrays = _this$dependencyGraph4.affectedArrays,
          contentChanges = _this$dependencyGraph4.contentChanges;

      this.columnSearch.addColumns(addedColumns);
      this.columnSearch.applyChanges(contentChanges.getChanges());
      this.stats.measure(_statistics.StatType.TRANSFORM_ASTS, function () {
        var transformation = new _AddColumnsTransformer.AddColumnsTransformer(addedColumns);
        transformation.performEagerTransformations(_this12.dependencyGraph, _this12.parser);

        _this12.lazilyTransformingAstService.addTransformation(transformation);
      });
      this.rewriteAffectedArrays(affectedArrays);
    }
    /**
     * Returns true if row number is outside of given sheet.
     *
     * @param column - row number
     * @param sheet - sheet id number
     */

  }, {
    key: "columnEffectivelyNotInSheet",
    value: function columnEffectivelyNotInSheet(column, sheet) {
      var width = this.dependencyGraph.addressMapping.getWidth(sheet);
      return column >= width;
    }
  }, {
    key: "adjustNamedExpressionEdges",
    value: function adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {
      if (sheetId === undefined) {
        return;
      }

      var localVertex = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);
      var globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);
      var globalVertex = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);

      var _iterator12 = _createForOfIteratorHelper(this.dependencyGraph.graph.adjacentNodes(globalVertex)),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var adjacentNode = _step12.value;

          if (adjacentNode instanceof _DependencyGraph.FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {
            var ast = adjacentNode.getFormula(this.lazilyTransformingAstService);
            var formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);

            var _this$parser$fetchCac3 = this.parser.fetchCachedResultForAst(ast),
                dependencies = _this$parser$fetchCac3.dependencies;

            var _iterator13 = _createForOfIteratorHelper((0, _absolutizeDependencies.absolutizeDependencies)(dependencies, formulaAddress)),
                _step13;

            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var dependency = _step13.value;

                if (dependency instanceof _parser.NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {
                  this.dependencyGraph.graph.removeEdge(globalVertex, adjacentNode);
                  this.dependencyGraph.graph.addEdge(localVertex, adjacentNode);
                }
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
    }
  }, {
    key: "storeNamedExpressionInCell",
    value: function storeNamedExpressionInCell(address, expression) {
      var parsedCellContent = this.cellContentParser.parse(expression);

      if (parsedCellContent instanceof _CellContentParser.CellContent.Formula) {
        var parsingResult = this.parser.parse(parsedCellContent.formula, (0, _Cell.simpleCellAddress)(-1, 0, 0));

        if ((0, _NamedExpressions.doesContainRelativeReferences)(parsingResult.ast)) {
          throw new _errors.NoRelativeAddressesAllowedError();
        }

        var ast = parsingResult.ast,
            hasVolatileFunction = parsingResult.hasVolatileFunction,
            hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,
            dependencies = parsingResult.dependencies;
        this.dependencyGraph.setFormulaToCell(address, ast, (0, _absolutizeDependencies.absolutizeDependencies)(dependencies, address), _ArraySize.ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);
      } else if (parsedCellContent instanceof _CellContentParser.CellContent.Empty) {
        this.setCellEmpty(address);
      } else {
        this.setValueToCell({
          parsedValue: parsedCellContent.value,
          rawValue: expression
        }, address);
      }
    }
  }, {
    key: "updateNamedExpressionsForMovedCells",
    value: function updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {
      if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {
        return [];
      }

      var addedGlobalNamedExpressions = [];

      var targetRange = _AbsoluteCellRange.AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);

      var _iterator14 = _createForOfIteratorHelper(targetRange.addresses(this.dependencyGraph)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var formulaAddress = _step14.value;
          var vertex = this.addressMapping.fetchCell(formulaAddress);

          if (vertex instanceof _DependencyGraph.FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {
            var ast = vertex.getFormula(this.lazilyTransformingAstService);

            var _this$parser$fetchCac4 = this.parser.fetchCachedResultForAst(ast),
                dependencies = _this$parser$fetchCac4.dependencies;

            addedGlobalNamedExpressions.push.apply(addedGlobalNamedExpressions, _toConsumableArray(this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies)));
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }

      return addedGlobalNamedExpressions;
    }
  }, {
    key: "updateNamedExpressionsForTargetAddress",
    value: function updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {
      if (sourceSheet === targetAddress.sheet) {
        return [];
      }

      var addedGlobalNamedExpressions = [];
      var vertex = this.addressMapping.fetchCell(targetAddress);

      var _iterator15 = _createForOfIteratorHelper((0, _absolutizeDependencies.absolutizeDependencies)(dependencies, targetAddress)),
          _step15;

      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var namedExpressionDependency = _step15.value;

          if (!(namedExpressionDependency instanceof _parser.NamedExpressionDependency)) {
            continue;
          }

          var expressionName = namedExpressionDependency.name;
          var sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet);
          var namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);
          var targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet) : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);

          if (targetScopeExpressionVertex !== sourceVertex) {
            this.dependencyGraph.graph.softRemoveEdge(sourceVertex, vertex);
            this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }

      return addedGlobalNamedExpressions;
    }
  }, {
    key: "allocateNamedExpressionAddressSpace",
    value: function allocateNamedExpressionAddressSpace() {
      this.dependencyGraph.addressMapping.addSheet(-1, new _DependencyGraph.SparseStrategy(0, 0));
    }
  }, {
    key: "copyOrFetchGlobalNamedExpressionVertex",
    value: function copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {
      var expression = this.namedExpressions.namedExpressionForScope(expressionName);

      if (expression === undefined) {
        expression = this.namedExpressions.addNamedExpression(expressionName);
        addedNamedExpressions.push(expression.normalizeExpressionName());

        if (sourceVertex instanceof _DependencyGraph.FormulaCellVertex) {
          var parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));
          var ast = parsingResult.ast,
              hasVolatileFunction = parsingResult.hasVolatileFunction,
              hasStructuralChangeFunction = parsingResult.hasStructuralChangeFunction,
              dependencies = parsingResult.dependencies;
          this.dependencyGraph.setFormulaToCell(expression.address, ast, (0, _absolutizeDependencies.absolutizeDependencies)(dependencies, expression.address), _ArraySize.ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);
        } else if (sourceVertex instanceof _DependencyGraph.EmptyCellVertex) {
          this.setCellEmpty(expression.address);
        } else if (sourceVertex instanceof _DependencyGraph.ValueCellVertex) {
          this.setValueToCell(sourceVertex.getValues(), expression.address);
        }
      }

      return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address);
    }
  }]);

  return Operations;
}();

exports.Operations = Operations;

function normalizeRemovedIndexes(indexes) {
  if (indexes.length <= 1) {
    return indexes;
  }

  var sorted = _toConsumableArray(indexes).sort(function (_ref6, _ref7) {
    var _ref8 = _slicedToArray(_ref6, 1),
        a = _ref8[0];

    var _ref9 = _slicedToArray(_ref7, 1),
        b = _ref9[0];

    return a - b;
  });
  /* merge overlapping and adjacent indexes */


  var merged = sorted.reduce(function (acc, _ref10) {
    var _ref11 = _slicedToArray(_ref10, 2),
        startIndex = _ref11[0],
        amount = _ref11[1];

    var previous = acc[acc.length - 1];
    var lastIndex = previous[0] + previous[1];

    if (startIndex <= lastIndex) {
      previous[1] += Math.max(0, amount - (lastIndex - startIndex));
    } else {
      acc.push([startIndex, amount]);
    }

    return acc;
  }, [sorted[0]]);
  /* shift further indexes */

  var shift = 0;

  for (var i = 0; i < merged.length; ++i) {
    merged[i][0] -= shift;
    shift += merged[i][1];
  }

  return merged;
}

function normalizeAddedIndexes(indexes) {
  if (indexes.length <= 1) {
    return indexes;
  }

  var sorted = _toConsumableArray(indexes).sort(function (_ref12, _ref13) {
    var _ref14 = _slicedToArray(_ref12, 1),
        a = _ref14[0];

    var _ref15 = _slicedToArray(_ref13, 1),
        b = _ref15[0];

    return a - b;
  });
  /* merge indexes with same start */


  var merged = sorted.reduce(function (acc, _ref16) {
    var _ref17 = _slicedToArray(_ref16, 2),
        startIndex = _ref17[0],
        amount = _ref17[1];

    var previous = acc[acc.length - 1];

    if (startIndex === previous[0]) {
      previous[1] = Math.max(previous[1], amount);
    } else {
      acc.push([startIndex, amount]);
    }

    return acc;
  }, [sorted[0]]);
  /* shift further indexes */

  var shift = 0;

  for (var i = 0; i < merged.length; ++i) {
    merged[i][0] += shift;
    shift += merged[i][1];
  }

  return merged;
}

function isPositiveInteger(x) {
  return Number.isInteger(x) && x > 0;
}

function isRowOrColumnRange(leftCorner, width, height) {
  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;
}