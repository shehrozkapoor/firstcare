"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

exports.__esModule = true;
exports.simpleSheetName = exports.sheetNameRegexp = exports.quotedSheetName = exports.buildLexerConfig = exports.WhiteSpace = exports.TimesOp = exports.StringLiteral = exports.RowRange = exports.RangeSeparator = exports.RParen = exports.RANGE_OPERATOR = exports.ProcedureName = exports.PowerOp = exports.PlusOp = exports.PercentOp = exports.NotEqualOp = exports.NamedExpression = exports.MultiplicationOp = exports.MinusOp = exports.LessThanOrEqualOp = exports.LessThanOp = exports.LParen = exports.GreaterThanOrEqualOp = exports.GreaterThanOp = exports.ErrorLiteral = exports.EqualsOp = exports.DivOp = exports.ConcatenateOp = exports.ColumnRange = exports.CellReference = exports.BooleanOp = exports.ArrayRParen = exports.ArrayLParen = exports.AdditionOp = exports.ABSOLUTE_OPERATOR = void 0;

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.array.concat.js");

var _chevrotain = require("chevrotain");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var RANGE_OPERATOR = ':';
exports.RANGE_OPERATOR = RANGE_OPERATOR;
var ABSOLUTE_OPERATOR = '$';
/* arithmetic */
// abstract for + -

exports.ABSOLUTE_OPERATOR = ABSOLUTE_OPERATOR;
var AdditionOp = (0, _chevrotain.createToken)({
  name: 'AdditionOp',
  pattern: _chevrotain.Lexer.NA
});
exports.AdditionOp = AdditionOp;
var PlusOp = (0, _chevrotain.createToken)({
  name: 'PlusOp',
  pattern: /\+/,
  categories: AdditionOp
});
exports.PlusOp = PlusOp;
var MinusOp = (0, _chevrotain.createToken)({
  name: 'MinusOp',
  pattern: /-/,
  categories: AdditionOp
}); // abstract for * /

exports.MinusOp = MinusOp;
var MultiplicationOp = (0, _chevrotain.createToken)({
  name: 'MultiplicationOp',
  pattern: _chevrotain.Lexer.NA
});
exports.MultiplicationOp = MultiplicationOp;
var TimesOp = (0, _chevrotain.createToken)({
  name: 'TimesOp',
  pattern: /\*/,
  categories: MultiplicationOp
});
exports.TimesOp = TimesOp;
var DivOp = (0, _chevrotain.createToken)({
  name: 'DivOp',
  pattern: /\//,
  categories: MultiplicationOp
});
exports.DivOp = DivOp;
var PowerOp = (0, _chevrotain.createToken)({
  name: 'PowerOp',
  pattern: /\^/
});
exports.PowerOp = PowerOp;
var PercentOp = (0, _chevrotain.createToken)({
  name: 'PercentOp',
  pattern: /%/
});
exports.PercentOp = PercentOp;
var BooleanOp = (0, _chevrotain.createToken)({
  name: 'BooleanOp',
  pattern: _chevrotain.Lexer.NA
});
exports.BooleanOp = BooleanOp;
var EqualsOp = (0, _chevrotain.createToken)({
  name: 'EqualsOp',
  pattern: /=/,
  categories: BooleanOp
});
exports.EqualsOp = EqualsOp;
var NotEqualOp = (0, _chevrotain.createToken)({
  name: 'NotEqualOp',
  pattern: /<>/,
  categories: BooleanOp
});
exports.NotEqualOp = NotEqualOp;
var GreaterThanOp = (0, _chevrotain.createToken)({
  name: 'GreaterThanOp',
  pattern: />/,
  categories: BooleanOp
});
exports.GreaterThanOp = GreaterThanOp;
var LessThanOp = (0, _chevrotain.createToken)({
  name: 'LessThanOp',
  pattern: /</,
  categories: BooleanOp
});
exports.LessThanOp = LessThanOp;
var GreaterThanOrEqualOp = (0, _chevrotain.createToken)({
  name: 'GreaterThanOrEqualOp',
  pattern: />=/,
  categories: BooleanOp
});
exports.GreaterThanOrEqualOp = GreaterThanOrEqualOp;
var LessThanOrEqualOp = (0, _chevrotain.createToken)({
  name: 'LessThanOrEqualOp',
  pattern: /<=/,
  categories: BooleanOp
});
exports.LessThanOrEqualOp = LessThanOrEqualOp;
var ConcatenateOp = (0, _chevrotain.createToken)({
  name: 'ConcatenateOp',
  pattern: /&/
});
/* addresses */

exports.ConcatenateOp = ConcatenateOp;
var simpleSheetName = "[A-Za-z0-9_\xC0-\u02AF]+";
exports.simpleSheetName = simpleSheetName;
var quotedSheetName = "'(((?!').|'')*)'";
exports.quotedSheetName = quotedSheetName;
var sheetNameRegexp = "(".concat(simpleSheetName, "|").concat(quotedSheetName, ")!");
exports.sheetNameRegexp = sheetNameRegexp;
var CellReference = (0, _chevrotain.createToken)({
  name: 'CellReference',
  pattern: new RegExp("(".concat(sheetNameRegexp, ")?\\").concat(ABSOLUTE_OPERATOR, "?[A-Za-z]+\\").concat(ABSOLUTE_OPERATOR, "?[0-9]+"))
});
exports.CellReference = CellReference;
var ColumnRange = (0, _chevrotain.createToken)({
  name: 'ColumnRange',
  pattern: new RegExp("(".concat(sheetNameRegexp, ")?\\").concat(ABSOLUTE_OPERATOR, "?[A-Za-z]+").concat(RANGE_OPERATOR, "(").concat(sheetNameRegexp, ")?\\").concat(ABSOLUTE_OPERATOR, "?[A-Za-z]+"))
});
exports.ColumnRange = ColumnRange;
var RowRange = (0, _chevrotain.createToken)({
  name: 'RowRange',
  pattern: new RegExp("(".concat(sheetNameRegexp, ")?\\").concat(ABSOLUTE_OPERATOR, "?[0-9]+").concat(RANGE_OPERATOR, "(").concat(sheetNameRegexp, ")?\\").concat(ABSOLUTE_OPERATOR, "?[0-9]+"))
});
exports.RowRange = RowRange;
var RangeSeparator = (0, _chevrotain.createToken)({
  name: 'RangeSeparator',
  pattern: "".concat(RANGE_OPERATOR)
});
/* parenthesis */

exports.RangeSeparator = RangeSeparator;
var LParen = (0, _chevrotain.createToken)({
  name: 'LParen',
  pattern: /\(/
});
exports.LParen = LParen;
var RParen = (0, _chevrotain.createToken)({
  name: 'RParen',
  pattern: /\)/
});
/* array parenthesis */

exports.RParen = RParen;
var ArrayLParen = (0, _chevrotain.createToken)({
  name: 'ArrayLParen',
  pattern: /{/
});
exports.ArrayLParen = ArrayLParen;
var ArrayRParen = (0, _chevrotain.createToken)({
  name: 'ArrayRParen',
  pattern: /}/
});
/* procedures */

exports.ArrayRParen = ArrayRParen;
var ProcedureName = (0, _chevrotain.createToken)({
  name: 'ProcedureName',
  pattern: /([A-Za-z\u00C0-\u02AF][A-Za-z0-9\u00C0-\u02AF._]*)\(/
});
/* named expressions */

exports.ProcedureName = ProcedureName;
var NamedExpression = (0, _chevrotain.createToken)({
  name: 'NamedExpression',
  pattern: /[A-Za-z\u00C0-\u02AF_][A-Za-z0-9\u00C0-\u02AF._]*/
});
/* string literal */

exports.NamedExpression = NamedExpression;
var StringLiteral = (0, _chevrotain.createToken)({
  name: 'StringLiteral',
  pattern: /"([^"\\]*(\\.[^"\\]*)*)"/
});
/* error literal */

exports.StringLiteral = StringLiteral;
var ErrorLiteral = (0, _chevrotain.createToken)({
  name: 'ErrorLiteral',
  pattern: /#[A-Za-z0-9\/]+[?!]?/
});
/* skipping whitespaces */

exports.ErrorLiteral = ErrorLiteral;
var WhiteSpace = (0, _chevrotain.createToken)({
  name: 'WhiteSpace',
  pattern: /[ \t\n\r]+/
});
exports.WhiteSpace = WhiteSpace;

var buildLexerConfig = function buildLexerConfig(config) {
  var offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');
  var errorMapping = config.errorMapping;
  var functionMapping = config.translationPackage.buildFunctionMapping();
  var ArrayRowSeparator = (0, _chevrotain.createToken)({
    name: 'ArrayRowSep',
    pattern: config.arrayRowSeparator
  });
  var ArrayColSeparator = (0, _chevrotain.createToken)({
    name: 'ArrayColSep',
    pattern: config.arrayColumnSeparator
  });
  /* configurable tokens */

  var ArgSeparator, inject;

  if (config.functionArgSeparator === config.arrayColumnSeparator) {
    ArgSeparator = ArrayColSeparator;
    inject = [];
  } else if (config.functionArgSeparator === config.arrayRowSeparator) {
    ArgSeparator = ArrayRowSeparator;
    inject = [];
  } else {
    ArgSeparator = (0, _chevrotain.createToken)({
      name: 'ArgSeparator',
      pattern: config.functionArgSeparator
    });
    inject = [ArgSeparator];
  }

  var NumberLiteral = (0, _chevrotain.createToken)({
    name: 'NumberLiteral',
    pattern: new RegExp("(([".concat(config.decimalSeparator, "]\\d+)|(\\d+([").concat(config.decimalSeparator, "]\\d*)?))(e[+-]?\\d+)?"))
  });
  var OffsetProcedureName = (0, _chevrotain.createToken)({
    name: 'OffsetProcedureName',
    pattern: new RegExp(offsetProcedureNameLiteral, 'i')
  });
  /* order is important, first pattern is used */

  var allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator].concat(_toConsumableArray(inject), [ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator]);
  return {
    ArgSeparator: ArgSeparator,
    NumberLiteral: NumberLiteral,
    OffsetProcedureName: OffsetProcedureName,
    ArrayRowSeparator: ArrayRowSeparator,
    ArrayColSeparator: ArrayColSeparator,
    allTokens: allTokens,
    errorMapping: errorMapping,
    functionMapping: functionMapping,
    decimalSeparator: config.decimalSeparator,
    maxColumns: config.maxColumns,
    maxRows: config.maxRows
  };
};

exports.buildLexerConfig = buildLexerConfig;