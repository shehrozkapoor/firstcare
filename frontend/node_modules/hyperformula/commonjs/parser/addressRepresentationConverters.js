"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.from.js");

exports.__esModule = true;
exports.columnAddressFromString = exports.cellAddressFromString = void 0;
exports.columnIndexToLabel = columnIndexToLabel;
exports.rowAddressFromString = void 0;
exports.sheetIndexToString = sheetIndexToString;
exports.simpleCellRangeToString = exports.simpleCellRangeFromString = exports.simpleCellAddressToString = exports.simpleCellAddressFromString = void 0;

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.number.constructor.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.string.replace.js");

var _AbsoluteCellRange = require("../AbsoluteCellRange");

var _Cell = require("../Cell");

var _CellAddress = require("./CellAddress");

var _ColumnAddress = require("./ColumnAddress");

var _LexerConfig = require("./LexerConfig");

var _RowAddress = require("./RowAddress");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var addressRegex = new RegExp("^(".concat(_LexerConfig.sheetNameRegexp, ")?(\\").concat(_LexerConfig.ABSOLUTE_OPERATOR, "?)([A-Za-z]+)(\\").concat(_LexerConfig.ABSOLUTE_OPERATOR, "?)([0-9]+)$"));
var columnRegex = new RegExp("^(".concat(_LexerConfig.sheetNameRegexp, ")?(\\").concat(_LexerConfig.ABSOLUTE_OPERATOR, "?)([A-Za-z]+)$"));
var rowRegex = new RegExp("^(".concat(_LexerConfig.sheetNameRegexp, ")?(\\").concat(_LexerConfig.ABSOLUTE_OPERATOR, "?)([0-9]+)$"));
var simpleSheetNameRegex = new RegExp("^".concat(_LexerConfig.simpleSheetName, "$"));
/**
 * Computes R0C0 representation of cell address based on it's string representation and base address.
 *
 * @param sheetMapping - mapping function needed to change name of a sheet to index
 * @param stringAddress - string representation of cell address, e.g. 'C64'
 * @param baseAddress - base address for R0C0 conversion
 * @returns object representation of address
 */

var cellAddressFromString = function cellAddressFromString(sheetMapping, stringAddress, baseAddress) {
  var result = addressRegex.exec(stringAddress);
  var col = columnLabelToIndex(result[6]);
  var sheet = extractSheetNumber(result, sheetMapping);

  if (sheet === undefined) {
    return undefined;
  }

  if (sheet === null) {
    sheet = undefined;
  }

  var row = Number(result[8]) - 1;

  if (result[5] === _LexerConfig.ABSOLUTE_OPERATOR && result[7] === _LexerConfig.ABSOLUTE_OPERATOR) {
    return _CellAddress.CellAddress.absolute(col, row, sheet);
  } else if (result[5] === _LexerConfig.ABSOLUTE_OPERATOR) {
    return _CellAddress.CellAddress.absoluteCol(col, row - baseAddress.row, sheet);
  } else if (result[7] === _LexerConfig.ABSOLUTE_OPERATOR) {
    return _CellAddress.CellAddress.absoluteRow(col - baseAddress.col, row, sheet);
  } else {
    return _CellAddress.CellAddress.relative(row - baseAddress.row, col - baseAddress.col, sheet);
  }
};

exports.cellAddressFromString = cellAddressFromString;

var columnAddressFromString = function columnAddressFromString(sheetMapping, stringAddress, baseAddress) {
  var result = columnRegex.exec(stringAddress);
  var sheet = extractSheetNumber(result, sheetMapping);

  if (sheet === undefined) {
    return undefined;
  }

  if (sheet === null) {
    sheet = undefined;
  }

  var col = columnLabelToIndex(result[6]);

  if (result[5] === _LexerConfig.ABSOLUTE_OPERATOR) {
    return _ColumnAddress.ColumnAddress.absolute(col, sheet);
  } else {
    return _ColumnAddress.ColumnAddress.relative(col - baseAddress.col, sheet);
  }
};

exports.columnAddressFromString = columnAddressFromString;

var rowAddressFromString = function rowAddressFromString(sheetMapping, stringAddress, baseAddress) {
  var result = rowRegex.exec(stringAddress);
  var sheet = extractSheetNumber(result, sheetMapping);

  if (sheet === undefined) {
    return undefined;
  }

  if (sheet === null) {
    sheet = undefined;
  }

  var row = Number(result[6]) - 1;

  if (result[5] === _LexerConfig.ABSOLUTE_OPERATOR) {
    return _RowAddress.RowAddress.absolute(row, sheet);
  } else {
    return _RowAddress.RowAddress.relative(row - baseAddress.row, sheet);
  }
};
/**
 * Computes simple (absolute) address of a cell address based on its string representation.
 * If sheet name present in string representation but is not present in sheet mapping, returns undefined.
 * If sheet name is not present in string representation, returns {@param sheetContext} as sheet number
 *
 * @param sheetMapping - mapping function needed to change name of a sheet to index
 * @param stringAddress - string representation of cell address, e.g. 'C64'
 * @param sheetContext - sheet in context of which we should parse the address
 * @returns absolute representation of address, e.g. { sheet: 0, col: 1, row: 1 }
 */


exports.rowAddressFromString = rowAddressFromString;

var simpleCellAddressFromString = function simpleCellAddressFromString(sheetMapping, stringAddress, sheetContext) {
  var result = addressRegex.exec(stringAddress);
  var col = columnLabelToIndex(result[6]);
  var sheet = extractSheetNumber(result, sheetMapping);

  if (sheet === undefined) {
    return undefined;
  }

  if (sheet === null) {
    sheet = sheetContext;
  }

  var row = Number(result[8]) - 1;
  return (0, _Cell.simpleCellAddress)(sheet, col, row);
};

exports.simpleCellAddressFromString = simpleCellAddressFromString;

var simpleCellRangeFromString = function simpleCellRangeFromString(sheetMapping, stringAddress, sheetContext) {
  var split = stringAddress.split(_LexerConfig.RANGE_OPERATOR);

  if (split.length !== 2) {
    return undefined;
  }

  var _split = _slicedToArray(split, 2),
      startString = _split[0],
      endString = _split[1];

  var start = simpleCellAddressFromString(sheetMapping, startString, sheetContext);

  if (start === undefined) {
    return undefined;
  }

  var end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);

  if (end === undefined) {
    return undefined;
  }

  if (start.sheet !== end.sheet) {
    return undefined;
  }

  return (0, _AbsoluteCellRange.simpleCellRange)(start, end);
};
/**
 * Returns string representation of absolute address
 * If sheet index is not present in sheet mapping, returns undefined
 *
 * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name
 * @param address - object representation of absolute address
 * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name
 * */


exports.simpleCellRangeFromString = simpleCellRangeFromString;

var simpleCellAddressToString = function simpleCellAddressToString(sheetIndexMapping, address, sheetIndex) {
  var column = columnIndexToLabel(address.col);
  var sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);

  if (sheetName === undefined) {
    return undefined;
  }

  if (sheetIndex !== address.sheet) {
    return "".concat(sheetName, "!").concat(column).concat(address.row + 1);
  } else {
    return "".concat(column).concat(address.row + 1);
  }
};

exports.simpleCellAddressToString = simpleCellAddressToString;

var simpleCellRangeToString = function simpleCellRangeToString(sheetIndexMapping, address, sheetIndex) {
  var startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);
  var endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);

  if (startString === undefined || endString === undefined) {
    return undefined;
  } else {
    return "".concat(startString).concat(_LexerConfig.RANGE_OPERATOR).concat(endString);
  }
};
/**
 * Convert column label to index
 *
 * @param columnStringRepresentation - column label (e.g. 'AAB')
 * @returns column index
 * */


exports.simpleCellRangeToString = simpleCellRangeToString;

function columnLabelToIndex(columnStringRepresentation) {
  if (columnStringRepresentation.length === 1) {
    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;
  } else {
    return columnStringRepresentation.split('').reduce(function (currentColumn, nextLetter) {
      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);
    }, 0) - 1;
  }
}
/**
 * Converts column index to label
 *
 * @param column - address to convert
 * @returns string representation, e.g. 'AAB'
 */


function columnIndexToLabel(column) {
  var result = '';

  while (column >= 0) {
    result = String.fromCharCode(column % 26 + 97) + result;
    column = Math.floor(column / 26) - 1;
  }

  return result.toUpperCase();
}

function sheetIndexToString(sheetId, sheetMappingFn) {
  var sheetName = sheetMappingFn(sheetId);

  if (sheetName === undefined) {
    return undefined;
  }

  if (simpleSheetNameRegex.test(sheetName)) {
    return sheetName;
  } else {
    sheetName = sheetName.replace(/'/g, "''");
    return "'".concat(sheetName, "'");
  }
}

function extractSheetNumber(regexResult, sheetMapping) {
  var _a;

  var maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];

  if (maybeSheetName) {
    maybeSheetName = maybeSheetName.replace(/''/g, "'");
    return sheetMapping(maybeSheetName);
  } else {
    return null;
  }
}