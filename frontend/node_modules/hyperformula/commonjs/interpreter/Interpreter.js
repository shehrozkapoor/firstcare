"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.regexp.exec.js");

exports.__esModule = true;
exports.Interpreter = void 0;

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.map.js");

var _AbsoluteCellRange = require("../AbsoluteCellRange");

var _ArrayValue = require("../ArrayValue");

var _Cell = require("../Cell");

var _errorMessage = require("../error-message");

var _Ast = require("../parser/Ast");

var _ArithmeticHelper = require("./ArithmeticHelper");

var _Criterion = require("./Criterion");

var _FunctionRegistry = require("./FunctionRegistry");

var _InterpreterState = require("./InterpreterState");

var _InterpreterValue = require("./InterpreterValue");

var _SimpleRangeValue = require("./SimpleRangeValue");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var Interpreter = /*#__PURE__*/function () {
  function Interpreter(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper) {
    var _this = this;

    _classCallCheck(this, Interpreter);

    this.config = config;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.stats = stats;
    this.arithmeticHelper = arithmeticHelper;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.serialization = serialization;
    this.arraySizePredictor = arraySizePredictor;
    this.dateTimeHelper = dateTimeHelper;

    this.equalOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.eq, arg1, arg2);
    };

    this.notEqualOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.neq, arg1, arg2);
    };

    this.greaterThanOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.gt, arg1, arg2);
    };

    this.lessThanOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.lt, arg1, arg2);
    };

    this.greaterThanOrEqualOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.geq, arg1, arg2);
    };

    this.lessThanOrEqualOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.leq, arg1, arg2);
    };

    this.concatOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.concat, (0, _ArithmeticHelper.coerceScalarToString)(arg1), (0, _ArithmeticHelper.coerceScalarToString)(arg2));
    };

    this.plusOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.addWithEpsilon, _this.arithmeticHelper.coerceScalarToNumberOrError(arg1), _this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    };

    this.minusOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.subtract, _this.arithmeticHelper.coerceScalarToNumberOrError(arg1), _this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    };

    this.timesOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.multiply, _this.arithmeticHelper.coerceScalarToNumberOrError(arg1), _this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    };

    this.powerOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.pow, _this.arithmeticHelper.coerceScalarToNumberOrError(arg1), _this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    };

    this.divOp = function (arg1, arg2) {
      return binaryErrorWrapper(_this.arithmeticHelper.divide, _this.arithmeticHelper.coerceScalarToNumberOrError(arg1), _this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    };

    this.unaryMinusOp = function (arg) {
      return unaryErrorWrapper(_this.arithmeticHelper.unaryMinus, _this.arithmeticHelper.coerceScalarToNumberOrError(arg));
    };

    this.percentOp = function (arg) {
      return unaryErrorWrapper(_this.arithmeticHelper.unaryPercent, _this.arithmeticHelper.coerceScalarToNumberOrError(arg));
    };

    this.unaryPlusOp = function (arg) {
      return _this.arithmeticHelper.unaryPlus(arg);
    };

    this.functionRegistry.initializePlugins(this);
    this.criterionBuilder = new _Criterion.CriterionBuilder(config);
  }

  _createClass(Interpreter, [{
    key: "evaluateAst",
    value: function evaluateAst(ast, state) {
      var val = this.evaluateAstWithoutPostprocessing(ast, state);

      if ((0, _InterpreterValue.isExtendedNumber)(val)) {
        if ((0, _ArithmeticHelper.isNumberOverflow)((0, _InterpreterValue.getRawValue)(val))) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NaN);
        } else {
          val = (0, _InterpreterValue.cloneNumber)(val, (0, _ArithmeticHelper.fixNegativeZero)((0, _InterpreterValue.getRawValue)(val)));
        }
      }

      if (val instanceof _SimpleRangeValue.SimpleRangeValue && val.height() === 1 && val.width() === 1) {
        var _val$data = _slicedToArray(val.data, 1);

        var _val$data$ = _slicedToArray(_val$data[0], 1);

        val = _val$data$[0];
      }

      return wrapperForRootVertex(val, state.formulaVertex);
    }
  }, {
    key: "getGpuInstance",
    value: function getGpuInstance() {
      var mode = this.config.gpuMode;
      var gpujs = this.config.gpujs;

      if (gpujs === undefined) {
        throw Error('Cannot instantiate GPU.js. Constructor not provided.');
      }

      if (!this.gpu) {
        this.gpu = new gpujs({
          mode: mode
        });
      }

      return this.gpu;
    }
  }, {
    key: "destroyGpu",
    value: function destroyGpu() {
      var _a;

      (_a = this.gpu) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Calculates cell value from formula abstract syntax tree
     *
     * @param formula - abstract syntax tree of formula
     * @param formulaAddress - address of the cell in which formula is located
     */

  }, {
    key: "evaluateAstWithoutPostprocessing",
    value: function evaluateAstWithoutPostprocessing(ast, state) {
      switch (ast.type) {
        case _Ast.AstNodeType.EMPTY:
          {
            return _InterpreterValue.EmptyValue;
          }

        case _Ast.AstNodeType.CELL_REFERENCE:
          {
            var address = ast.reference.toSimpleCellAddress(state.formulaAddress);

            if ((0, _Cell.invalidSimpleCellAddress)(address)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.BadRef);
            }

            return this.dependencyGraph.getCellValue(address);
          }

        case _Ast.AstNodeType.NUMBER:
        case _Ast.AstNodeType.STRING:
          {
            return ast.value;
          }

        case _Ast.AstNodeType.CONCATENATE_OP:
          {
            var leftResult = this.evaluateAst(ast.left, state);
            var rightResult = this.evaluateAst(ast.right, state);
            return this.binaryRangeWrapper(this.concatOp, leftResult, rightResult, state);
          }

        case _Ast.AstNodeType.EQUALS_OP:
          {
            var _leftResult = this.evaluateAst(ast.left, state);

            var _rightResult = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.equalOp, _leftResult, _rightResult, state);
          }

        case _Ast.AstNodeType.NOT_EQUAL_OP:
          {
            var _leftResult2 = this.evaluateAst(ast.left, state);

            var _rightResult2 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.notEqualOp, _leftResult2, _rightResult2, state);
          }

        case _Ast.AstNodeType.GREATER_THAN_OP:
          {
            var _leftResult3 = this.evaluateAst(ast.left, state);

            var _rightResult3 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.greaterThanOp, _leftResult3, _rightResult3, state);
          }

        case _Ast.AstNodeType.LESS_THAN_OP:
          {
            var _leftResult4 = this.evaluateAst(ast.left, state);

            var _rightResult4 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.lessThanOp, _leftResult4, _rightResult4, state);
          }

        case _Ast.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
          {
            var _leftResult5 = this.evaluateAst(ast.left, state);

            var _rightResult5 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.greaterThanOrEqualOp, _leftResult5, _rightResult5, state);
          }

        case _Ast.AstNodeType.LESS_THAN_OR_EQUAL_OP:
          {
            var _leftResult6 = this.evaluateAst(ast.left, state);

            var _rightResult6 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.lessThanOrEqualOp, _leftResult6, _rightResult6, state);
          }

        case _Ast.AstNodeType.PLUS_OP:
          {
            var _leftResult7 = this.evaluateAst(ast.left, state);

            var _rightResult7 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.plusOp, _leftResult7, _rightResult7, state);
          }

        case _Ast.AstNodeType.MINUS_OP:
          {
            var _leftResult8 = this.evaluateAst(ast.left, state);

            var _rightResult8 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.minusOp, _leftResult8, _rightResult8, state);
          }

        case _Ast.AstNodeType.TIMES_OP:
          {
            var _leftResult9 = this.evaluateAst(ast.left, state);

            var _rightResult9 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.timesOp, _leftResult9, _rightResult9, state);
          }

        case _Ast.AstNodeType.POWER_OP:
          {
            var _leftResult10 = this.evaluateAst(ast.left, state);

            var _rightResult10 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.powerOp, _leftResult10, _rightResult10, state);
          }

        case _Ast.AstNodeType.DIV_OP:
          {
            var _leftResult11 = this.evaluateAst(ast.left, state);

            var _rightResult11 = this.evaluateAst(ast.right, state);

            return this.binaryRangeWrapper(this.divOp, _leftResult11, _rightResult11, state);
          }

        case _Ast.AstNodeType.PLUS_UNARY_OP:
          {
            var result = this.evaluateAst(ast.value, state);
            return this.unaryRangeWrapper(this.unaryPlusOp, result, state);
          }

        case _Ast.AstNodeType.MINUS_UNARY_OP:
          {
            var _result = this.evaluateAst(ast.value, state);

            return this.unaryRangeWrapper(this.unaryMinusOp, _result, state);
          }

        case _Ast.AstNodeType.PERCENT_OP:
          {
            var _result2 = this.evaluateAst(ast.value, state);

            return this.unaryRangeWrapper(this.percentOp, _result2, state);
          }

        case _Ast.AstNodeType.FUNCTION_CALL:
          {
            if (this.config.licenseKeyValidityState !== "valid"
            /* VALID */
            && !_FunctionRegistry.FunctionRegistry.functionIsProtected(ast.procedureName)) {
              return new _Cell.CellError(_Cell.ErrorType.LIC, _errorMessage.ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));
            }

            var pluginFunction = this.functionRegistry.getFunction(ast.procedureName);

            if (pluginFunction !== undefined) {
              return pluginFunction(ast, new _InterpreterState.InterpreterState(state.formulaAddress, state.arraysFlag || this.functionRegistry.isArrayFunction(ast.procedureName), state.formulaVertex));
            } else {
              return new _Cell.CellError(_Cell.ErrorType.NAME, _errorMessage.ErrorMessage.FunctionName(ast.procedureName));
            }
          }

        case _Ast.AstNodeType.NAMED_EXPRESSION:
          {
            var namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, state.formulaAddress.sheet);

            if (namedExpression) {
              return this.dependencyGraph.getCellValue(namedExpression.address);
            } else {
              return new _Cell.CellError(_Cell.ErrorType.NAME, _errorMessage.ErrorMessage.NamedExpressionName(ast.expressionName));
            }
          }

        case _Ast.AstNodeType.CELL_RANGE:
          {
            if (!this.rangeSpansOneSheet(ast)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
            }

            var range = _AbsoluteCellRange.AbsoluteCellRange.fromCellRange(ast, state.formulaAddress);

            var arrayVertex = this.dependencyGraph.getArray(range);

            if (arrayVertex) {
              var array = arrayVertex.array;

              if (array instanceof _ArrayValue.NotComputedArray) {
                throw new Error('Array should be already computed');
              } else if (array instanceof _Cell.CellError) {
                return array;
              } else if (array instanceof _ArrayValue.ArrayValue) {
                return _SimpleRangeValue.SimpleRangeValue.fromRange(array.raw(), range, this.dependencyGraph);
              } else {
                throw new Error('Unknown array');
              }
            } else {
              return _SimpleRangeValue.SimpleRangeValue.onlyRange(range, this.dependencyGraph);
            }
          }

        case _Ast.AstNodeType.COLUMN_RANGE:
          {
            if (!this.rangeSpansOneSheet(ast)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
            }

            var _range = _AbsoluteCellRange.AbsoluteColumnRange.fromColumnRange(ast, state.formulaAddress);

            return _SimpleRangeValue.SimpleRangeValue.onlyRange(_range, this.dependencyGraph);
          }

        case _Ast.AstNodeType.ROW_RANGE:
          {
            if (!this.rangeSpansOneSheet(ast)) {
              return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.RangeManySheets);
            }

            var _range2 = _AbsoluteCellRange.AbsoluteRowRange.fromRowRangeAst(ast, state.formulaAddress);

            return _SimpleRangeValue.SimpleRangeValue.onlyRange(_range2, this.dependencyGraph);
          }

        case _Ast.AstNodeType.PARENTHESIS:
          {
            return this.evaluateAst(ast.expression, state);
          }

        case _Ast.AstNodeType.ARRAY:
          {
            var totalWidth = undefined;
            var ret = [];

            var _iterator = _createForOfIteratorHelper(ast.args),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var astRow = _step.value;
                var rowHeight = undefined;
                var rowRet = [];

                var _iterator2 = _createForOfIteratorHelper(astRow),
                    _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var astIt = _step2.value;
                    var arr = (0, _ArithmeticHelper.coerceToRange)(this.evaluateAst(astIt, state));
                    var height = arr.height();

                    if (rowHeight === undefined) {
                      rowHeight = height;
                      rowRet.push.apply(rowRet, _toConsumableArray(arr.data));
                    } else if (rowHeight === height) {
                      for (var i = 0; i < height; i++) {
                        var _rowRet$i;

                        (_rowRet$i = rowRet[i]).push.apply(_rowRet$i, _toConsumableArray(arr.data[i]));
                      }
                    } else {
                      return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.SizeMismatch);
                    }
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

                var width = rowRet[0].length;

                if (totalWidth === undefined) {
                  totalWidth = width;
                  ret.push.apply(ret, rowRet);
                } else if (totalWidth === width) {
                  ret.push.apply(ret, rowRet);
                } else {
                  return new _Cell.CellError(_Cell.ErrorType.REF, _errorMessage.ErrorMessage.SizeMismatch);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            return _SimpleRangeValue.SimpleRangeValue.onlyValues(ret);
          }

        case _Ast.AstNodeType.ERROR_WITH_RAW_INPUT:
        case _Ast.AstNodeType.ERROR:
          {
            return ast.error;
          }
      }
    }
  }, {
    key: "rangeSpansOneSheet",
    value: function rangeSpansOneSheet(ast) {
      return ast.start.sheet === ast.end.sheet;
    }
  }, {
    key: "unaryRangeWrapper",
    value: function unaryRangeWrapper(op, arg, state) {
      var _a;

      if (arg instanceof _SimpleRangeValue.SimpleRangeValue && !state.arraysFlag) {
        arg = (_a = (0, _ArithmeticHelper.coerceRangeToScalar)(arg, state)) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
      }

      if (arg instanceof _Cell.CellError) {
        return arg;
      }

      if (arg instanceof _SimpleRangeValue.SimpleRangeValue) {
        var newRaw = arg.data.map(function (row) {
          return row.map(op);
        });
        return _SimpleRangeValue.SimpleRangeValue.onlyValues(newRaw);
      }

      return op(arg);
    }
  }, {
    key: "binaryRangeWrapper",
    value: function binaryRangeWrapper(op, arg1, arg2, state) {
      var _a, _b;

      if (arg1 instanceof _SimpleRangeValue.SimpleRangeValue && !state.arraysFlag) {
        arg1 = (_a = (0, _ArithmeticHelper.coerceRangeToScalar)(arg1, state)) !== null && _a !== void 0 ? _a : new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
      }

      if (arg1 instanceof _Cell.CellError) {
        return arg1;
      }

      if (arg2 instanceof _SimpleRangeValue.SimpleRangeValue && !state.arraysFlag) {
        arg2 = (_b = (0, _ArithmeticHelper.coerceRangeToScalar)(arg2, state)) !== null && _b !== void 0 ? _b : new _Cell.CellError(_Cell.ErrorType.VALUE, _errorMessage.ErrorMessage.ScalarExpected);
      }

      if (arg2 instanceof _Cell.CellError) {
        return arg2;
      }

      if (arg1 instanceof _SimpleRangeValue.SimpleRangeValue || arg2 instanceof _SimpleRangeValue.SimpleRangeValue) {
        if (!(arg1 instanceof _SimpleRangeValue.SimpleRangeValue)) {
          if (arg2.isAdHoc()) {
            var raw2 = arg2.data;

            for (var i = 0; i < raw2.length; i++) {
              for (var j = 0; j < raw2[0].length; j++) {
                raw2[i][j] = op(arg1, raw2[i][j]);
              }
            }

            return _SimpleRangeValue.SimpleRangeValue.onlyValues(raw2);
          } else {
            arg1 = _SimpleRangeValue.SimpleRangeValue.fromScalar(arg1);
          }
        }

        if (!(arg2 instanceof _SimpleRangeValue.SimpleRangeValue)) {
          if (arg1.isAdHoc()) {
            var raw1 = arg1.data;

            for (var _i2 = 0; _i2 < raw1.length; _i2++) {
              for (var _j = 0; _j < raw1[0].length; _j++) {
                raw1[_i2][_j] = op(raw1[_i2][_j], arg2);
              }
            }

            return _SimpleRangeValue.SimpleRangeValue.onlyValues(raw1);
          } else {
            arg2 = _SimpleRangeValue.SimpleRangeValue.fromScalar(arg2);
          }
        }

        if (arg1.width() === arg2.width() && arg1.height() === arg2.height()) {
          if (arg1.isAdHoc()) {
            var _raw = arg1.data;
            var _raw2 = arg2.data;

            for (var _i3 = 0; _i3 < _raw.length; _i3++) {
              for (var _j2 = 0; _j2 < _raw[0].length; _j2++) {
                _raw[_i3][_j2] = op(_raw[_i3][_j2], _raw2[_i3][_j2]);
              }
            }

            return _SimpleRangeValue.SimpleRangeValue.onlyValues(_raw);
          }

          if (arg2.isAdHoc()) {
            var _raw3 = arg1.data;
            var _raw4 = arg2.data;

            for (var _i4 = 0; _i4 < _raw3.length; _i4++) {
              for (var _j3 = 0; _j3 < _raw3[0].length; _j3++) {
                _raw4[_i4][_j3] = op(_raw3[_i4][_j3], _raw4[_i4][_j3]);
              }
            }

            return _SimpleRangeValue.SimpleRangeValue.onlyValues(_raw4);
          }
        }

        var width = Math.max(arg1.width(), arg2.width());
        var height = Math.max(arg1.height(), arg2.height());
        var ret = Array(height);

        for (var _i5 = 0; _i5 < height; _i5++) {
          ret[_i5] = Array(width);
        }

        for (var _i6 = 0; _i6 < height; _i6++) {
          var i1 = arg1.height() !== 1 ? _i6 : 0;
          var i2 = arg2.height() !== 1 ? _i6 : 0;

          for (var _j4 = 0; _j4 < width; _j4++) {
            var j1 = arg1.width() !== 1 ? _j4 : 0;
            var j2 = arg2.width() !== 1 ? _j4 : 0;

            if (i1 < arg1.height() && i2 < arg2.height() && j1 < arg1.width() && j2 < arg2.width()) {
              ret[_i6][_j4] = op(arg1.data[i1][j1], arg2.data[i2][j2]);
            } else {
              ret[_i6][_j4] = new _Cell.CellError(_Cell.ErrorType.NA);
            }
          }
        }

        return _SimpleRangeValue.SimpleRangeValue.onlyValues(ret);
      }

      return op(arg1, arg2);
    }
  }]);

  return Interpreter;
}();

exports.Interpreter = Interpreter;

function unaryErrorWrapper(op, arg) {
  if (arg instanceof _Cell.CellError) {
    return arg;
  } else {
    return op(arg);
  }
}

function binaryErrorWrapper(op, arg1, arg2) {
  if (arg1 instanceof _Cell.CellError) {
    return arg1;
  } else if (arg2 instanceof _Cell.CellError) {
    return arg2;
  } else {
    return op(arg1, arg2);
  }
}

function wrapperForRootVertex(val, vertex) {
  if (val instanceof _Cell.CellError && vertex !== undefined) {
    return val.attachRootVertex(vertex);
  }

  return val;
}