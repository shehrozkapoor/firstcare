"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

require("core-js/modules/es.reflect.construct.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

exports.__esModule = true;
exports.RadixConversionPlugin = void 0;

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.object.get-prototype-of.js");

var _Cell = require("../../Cell");

var _errorMessage = require("../../error-message");

var _format = require("../../format/format");

var _FunctionPlugin2 = require("./FunctionPlugin");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var MAX_LENGTH = 10;
var DECIMAL_NUMBER_OF_BITS = 255;
var MIN_BASE = 2;
var MAX_BASE = 36;
var ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';

var RadixConversionPlugin = /*#__PURE__*/function (_FunctionPlugin) {
  _inherits(RadixConversionPlugin, _FunctionPlugin);

  var _super = _createSuper(RadixConversionPlugin);

  function RadixConversionPlugin() {
    _classCallCheck(this, RadixConversionPlugin);

    return _super.apply(this, arguments);
  }

  _createClass(RadixConversionPlugin, [{
    key: "dec2bin",
    value: function dec2bin(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('DEC2BIN'), function (value, places) {
        return decimalToBaseWithExactPadding(value, 2, places);
      });
    }
  }, {
    key: "dec2oct",
    value: function dec2oct(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('DEC2OCT'), function (value, places) {
        return decimalToBaseWithExactPadding(value, 8, places);
      });
    }
  }, {
    key: "dec2hex",
    value: function dec2hex(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('DEC2HEX'), function (value, places) {
        return decimalToBaseWithExactPadding(value, 16, places);
      });
    }
  }, {
    key: "bin2dec",
    value: function bin2dec(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('BIN2DEC'), function (binary) {
        var binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);

        if (binaryWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotBinary);
        }

        return twoComplementToDecimal(binaryWithSign, 2);
      });
    }
  }, {
    key: "bin2oct",
    value: function bin2oct(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('BIN2OCT'), function (binary, places) {
        var binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);

        if (binaryWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotBinary);
        }

        return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 8, places);
      });
    }
  }, {
    key: "bin2hex",
    value: function bin2hex(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('BIN2HEX'), function (binary, places) {
        var binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);

        if (binaryWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotBinary);
        }

        return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 16, places);
      });
    }
  }, {
    key: "oct2dec",
    value: function oct2dec(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('OCT2DEC'), function (octal) {
        var octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);

        if (octalWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotOctal);
        }

        return twoComplementToDecimal(octalWithSign, 8);
      });
    }
  }, {
    key: "oct2bin",
    value: function oct2bin(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('OCT2BIN'), function (octal, places) {
        var octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);

        if (octalWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotOctal);
        }

        return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 2, places);
      });
    }
  }, {
    key: "oct2hex",
    value: function oct2hex(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('OCT2HEX'), function (octal, places) {
        var octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);

        if (octalWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotOctal);
        }

        return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 16, places);
      });
    }
  }, {
    key: "hex2dec",
    value: function hex2dec(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('HEX2DEC'), function (hexadecimal) {
        var hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);

        if (hexadecimalWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotHex);
        }

        return twoComplementToDecimal(hexadecimalWithSign, 16);
      });
    }
  }, {
    key: "hex2bin",
    value: function hex2bin(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('HEX2BIN'), function (hexadecimal, places) {
        var hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);

        if (hexadecimalWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotHex);
        }

        return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 2, places);
      });
    }
  }, {
    key: "hex2oct",
    value: function hex2oct(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('HEX2OCT'), function (hexadecimal, places) {
        var hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);

        if (hexadecimalWithSign === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotHex);
        }

        return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 8, places);
      });
    }
  }, {
    key: "base",
    value: function base(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('BASE'), decimalToBaseWithMinimumPadding);
    }
  }, {
    key: "decimal",
    value: function decimal(ast, state) {
      return this.runFunction(ast.args, state, this.metadata('DECIMAL'), function (arg, base) {
        var input = coerceStringToBase(arg, base, DECIMAL_NUMBER_OF_BITS);

        if (input === undefined) {
          return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.NotHex);
        }

        return parseInt(input, base);
      });
    }
  }]);

  return RadixConversionPlugin;
}(_FunctionPlugin2.FunctionPlugin);

exports.RadixConversionPlugin = RadixConversionPlugin;
RadixConversionPlugin.implementedFunctions = {
  'DEC2BIN': {
    method: 'dec2bin',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'DEC2OCT': {
    method: 'dec2oct',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'DEC2HEX': {
    method: 'dec2hex',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'BIN2DEC': {
    method: 'bin2dec',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }]
  },
  'BIN2OCT': {
    method: 'bin2oct',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'BIN2HEX': {
    method: 'bin2hex',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'OCT2DEC': {
    method: 'oct2dec',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }]
  },
  'OCT2BIN': {
    method: 'oct2bin',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'OCT2HEX': {
    method: 'oct2hex',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'HEX2DEC': {
    method: 'hex2dec',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }]
  },
  'HEX2BIN': {
    method: 'hex2bin',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'HEX2OCT': {
    method: 'hex2oct',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'DECIMAL': {
    method: 'decimal',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.STRING
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      minValue: MIN_BASE,
      maxValue: MAX_BASE
    }]
  },
  'BASE': {
    method: 'base',
    parameters: [{
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      minValue: MIN_BASE,
      maxValue: MAX_BASE
    }, {
      argumentType: _FunctionPlugin2.ArgumentTypes.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: DECIMAL_NUMBER_OF_BITS
    }]
  }
};

function coerceStringToBase(value, base, maxLength) {
  var baseAlphabet = ALPHABET.substr(0, base);
  var regex = new RegExp("^[".concat(baseAlphabet, "]+$"));

  if (value.length > maxLength || !regex.test(value)) {
    return undefined;
  }

  return value;
}

function decimalToBaseWithExactPadding(value, base, places) {
  if (value > maxValFromBase(base)) {
    return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.ValueBaseLarge);
  }

  if (value < minValFromBase(base)) {
    return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.ValueBaseSmall);
  }

  var result = decimalToRadixComplement(value, base);

  if (places === undefined || value < 0) {
    return result;
  } else if (result.length > places) {
    return new _Cell.CellError(_Cell.ErrorType.NUM, _errorMessage.ErrorMessage.ValueBaseLong);
  } else {
    return (0, _format.padLeft)(result, places);
  }
}

function minValFromBase(base) {
  return -Math.pow(base, MAX_LENGTH) / 2;
}

function maxValFromBase(base) {
  return -minValFromBase(base) - 1;
}

function decimalToBaseWithMinimumPadding(value, base, places) {
  var result = decimalToRadixComplement(value, base);

  if (places !== undefined && places > result.length) {
    return (0, _format.padLeft)(result, places);
  } else {
    return result;
  }
}

function decimalToRadixComplement(value, base) {
  var offset = value < 0 ? Math.pow(base, MAX_LENGTH) : 0;
  return (value + offset).toString(base).toUpperCase();
}

function twoComplementToDecimal(value, base) {
  var parsed = parseInt(value, base);
  var offset = Math.pow(base, MAX_LENGTH);
  return parsed >= offset / 2 ? parsed - offset : parsed;
}